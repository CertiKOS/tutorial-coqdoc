<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link href="coqdoc.css" rel="stylesheet" type="text/css" />
<title>tutorial.stack.Counter</title>
</head>

<body>

<div id="page">

<div id="header">
</div>

<div id="main">

<h1 class="libtitle">Library tutorial.stack.Counter</h1>

<div class="code">
</div>

<div class="doc">
<a name="lab689"></a><h1 class="section">Counter.v</h1>

 *
<a name="lab690"></a><h1 class="section">A single layer implementing a bounded counter.</h1>

 
<div class="paragraph"> </div>

 Compcert helper lib 
</div>
<div class="code">
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="compcert.lib.Coqlib.html#"><span class="id" title="library">Coqlib</span></a>.<br/>
</div>

<div class="doc">
Compcert types and semantics 
</div>
<div class="code">
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="compcert.common.AST.html#"><span class="id" title="library">AST</span></a>.<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="compcert.lib.Integers.html#"><span class="id" title="library">Integers</span></a>.<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="compcert.common.Values.html#"><span class="id" title="library">Values</span></a>.<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="compcert.common.Globalenvs.html#"><span class="id" title="library">Globalenvs</span></a>.<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="compcert.cfrontend.Clight.html#"><span class="id" title="library">Clight</span></a>.<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="compcert.cfrontend.Ctypes.html#"><span class="id" title="library">Ctypes</span></a>.<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="compcert.cfrontend.Cop.html#"><span class="id" title="library">Cop</span></a>.<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="compcert.common.Smallstep.html#"><span class="id" title="library">Smallstep</span></a>.<br/>
</div>

<div class="doc">
CertiKOS layer library 
</div>
<div class="code">
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="liblayers.logic.Semantics.html#"><span class="id" title="library">Semantics</span></a>.<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="liblayers.logic.Structures.html#"><span class="id" title="library">Structures</span></a>.<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="liblayers.compcertx.GenSem.html#"><span class="id" title="library">GenSem</span></a>.<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="liblayers.compcertx.CGenSem.html#"><span class="id" title="library">CGenSem</span></a>.<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="liblayers.compcertx.CPrimitives.html#"><span class="id" title="library">CPrimitives</span></a>.<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="liblayers.simrel.SimulationRelation.html#"><span class="id" title="library">SimulationRelation</span></a>.<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="liblayers.simrel.SimrelInvariant.html#"><span class="id" title="library">SimrelInvariant</span></a>.<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="liblayers.logic.LayerLogicImpl.html#"><span class="id" title="library">LayerLogicImpl</span></a>.<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="liblayers.logic.PseudoJoinReflection.html#"><span class="id" title="library">PseudoJoinReflection</span></a>.<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="liblayers.compcertx.ClightModules.html#"><span class="id" title="library">ClightModules</span></a>.<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="liblayers.compcertx.ClightXSemantics.html#"><span class="id" title="library">ClightXSemantics</span></a>.<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="liblayers.simrel.AbstractData.html#"><span class="id" title="library">AbstractData</span></a>.<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="liblayers.simrel.AbstractionRelation.html#"><span class="id" title="library">AbstractionRelation</span></a>.<br/>

<br/>
</div>

<div class="doc">
This file makes use of some tactics and lemmas defined in a library created
  for this tutorial. It is not necessary for you to read this file in order to
  follow the tutorial. 
</div>
<div class="code">
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="tutorial.common.TutoLib.html#"><span class="id" title="library">TutoLib</span></a>.<br/>

<br/>
</div>

<div class="doc">
This file is meant to demonstrate how the layer calculus used in CertiKOS
  works by implementing a simple layer consisting of a global counter variable
  <span class="inlinecode"><a class="idref" href="tutorial.stack.Counter.html#COUNTER"><span class="id" title="definition">COUNTER</span></a></span> that can be accessed and manipulated by the primitives
  <span class="inlinecode"><a class="idref" href="tutorial.stack.Counter.html#get_counter"><span class="id" title="definition">get_counter</span></a></span>, <span class="inlinecode"><a class="idref" href="tutorial.stack.Counter.html#incr_counter"><span class="id" title="definition">incr_counter</span></a></span>, and <span class="inlinecode"><a class="idref" href="tutorial.stack.Counter.html#decr_counter"><span class="id" title="definition">decr_counter</span></a></span>. The counter variable is
  bounded within in the range <span class="inlinecode">0</span> to <span class="inlinecode"><a class="idref" href="tutorial.stack.Counter.html#MAX_COUNTER"><span class="id" title="definition">MAX_COUNTER</span></a></span> and the semantics are such
  that calling <span class="inlinecode"><a class="idref" href="tutorial.stack.Counter.html#incr_counter"><span class="id" title="definition">incr_counter</span></a></span> (or <span class="inlinecode"><a class="idref" href="tutorial.stack.Counter.html#decr_counter"><span class="id" title="definition">decr_counter</span></a></span>) when <span class="inlinecode"><a class="idref" href="tutorial.stack.Counter.html#COUNTER"><span class="id" title="definition">COUNTER</span></a></span> is at its high
  (or low) bound results in an error. The underlay upon which this layer is
  built contains no abstract data or primitives. The overlay consists of the
  primitives described above and a <span class="inlinecode"><a class="idref" href="tutorial.stack.Counter.html#counter"><span class="id" title="projection">counter</span></a></span> of type <span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a></span> as abstract data
  with the invariant that <span class="inlinecode"><a class="idref" href="tutorial.stack.Counter.html#counter"><span class="id" title="projection">counter</span></a></span> <span class="inlinecode">≤</span> <span class="inlinecode"><a class="idref" href="tutorial.stack.Counter.html#MAX_COUNTER"><span class="id" title="definition">MAX_COUNTER</span></a></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Open</span> <span class="id" title="keyword">Scope</span> <span class="id" title="var">Z_scope</span>.<br/>

<br/>
</div>

<div class="doc">
The only constraint on the value of <span class="inlinecode"><a class="idref" href="tutorial.stack.Counter.html#MAX_COUNTER"><span class="id" title="definition">MAX_COUNTER</span></a></span> is that it is less than
  the maximum unsigned integer divided by <span class="inlinecode">4</span> since it will be used as an array
  index later on. We mark it <span class="inlinecode"><span class="id" title="keyword">Opaque</span></span> to ensure that later proofs do not depend
  directly on its value. 
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <a name="MAX_COUNTER"><span class="id" title="definition">MAX_COUNTER</span></a> : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> := 10.<br/>
<span class="id" title="keyword">Fact</span> <a name="MAX_COUNTER_range"><span class="id" title="lemma">MAX_COUNTER_range</span></a> : 4 <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.ZArith.BinInt.html#88e34ed7a73f02772126289867960764"><span class="id" title="notation">×</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.ZArith.BinInt.html#Z.of_nat"><span class="id" title="definition">Z.of_nat</span></a> <a class="idref" href="tutorial.stack.Counter.html#MAX_COUNTER"><span class="id" title="definition">MAX_COUNTER</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.ZArith.BinInt.html#208bafb0e148fe7fb7dcd812c227f4ee"><span class="id" title="notation">≤</span></a> <a class="idref" href="compcert.lib.Integers.html#Int.max_unsigned"><span class="id" title="definition">Int.max_unsigned</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
</div>

<div class="doc">
TUTORIAL: complete proof. Possible in 1 tactic. 
</div>
<div class="code">
<span class="id" title="var">Admitted</span>.<br/>
<span class="id" title="keyword">Global Opaque</span> <a class="idref" href="tutorial.stack.Counter.html#MAX_COUNTER"><span class="id" title="definition">MAX_COUNTER</span></a>.<br/>

<br/>
</div>

<div class="doc">
These are the identifiers for the primitives and the global counter
  variable. 
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <a name="get_counter"><span class="id" title="definition">get_counter</span></a> : <a class="idref" href="compcert.common.AST.html#ident"><span class="id" title="definition">ident</span></a> := 1%<span class="id" title="var">positive</span>.<br/>
<span class="id" title="keyword">Definition</span> <a name="incr_counter"><span class="id" title="definition">incr_counter</span></a> : <a class="idref" href="compcert.common.AST.html#ident"><span class="id" title="definition">ident</span></a> := 2%<span class="id" title="var">positive</span>.<br/>
<span class="id" title="keyword">Definition</span> <a name="decr_counter"><span class="id" title="definition">decr_counter</span></a> : <a class="idref" href="compcert.common.AST.html#ident"><span class="id" title="definition">ident</span></a> := 3%<span class="id" title="var">positive</span>.<br/>
<span class="id" title="keyword">Definition</span> <a name="COUNTER"><span class="id" title="definition">COUNTER</span></a> : <a class="idref" href="compcert.common.AST.html#ident"><span class="id" title="definition">ident</span></a> := 4%<span class="id" title="var">positive</span>.<br/>

<br/>
<span class="id" title="keyword">Notation</span> <a name="MAX_COUNTER_i"><span class="id" title="abbreviation">MAX_COUNTER_i</span></a> := (<a class="idref" href="compcert.lib.Integers.html#Int.repr"><span class="id" title="definition">Int.repr</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.ZArith.BinInt.html#Z.of_nat"><span class="id" title="definition">Z.of_nat</span></a> <a class="idref" href="tutorial.stack.Counter.html#MAX_COUNTER"><span class="id" title="definition">MAX_COUNTER</span></a>)).<br/>

<br/>
<span class="id" title="keyword">Section</span> <a name="Counter"><span class="id" title="section">Counter</span></a>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Context</span> `{<span class="id" title="var">Hmem</span>: <a class="idref" href="liblayers.simrel.MemWithData.html#BaseMemoryModel"><span class="id" title="class">BaseMemoryModel</span></a>}.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Context</span> `{<a class="idref" href="liblayers.compcertx.MakeProgramSpec.html#MakeProgram"><span class="id" title="class">MakeProgramSpec.MakeProgram</span></a>}.<br/>

<br/>
</div>

<div class="doc">
<a name="lab691"></a><h2 class="section">Abstract Data</h2>

</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="keyword">Section</span> <a name="Counter.AbsData"><span class="id" title="section">AbsData</span></a>.<br/>
</div>

<div class="doc">
<a name="lab692"></a><h3 class="section">Underlay</h3>

<div class="paragraph"> </div>

 The underlay has no abstract data, we model this as <span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#unit"><span class="id" title="inductive">unit</span></a></span> and declare
      <span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#unit"><span class="id" title="inductive">unit</span></a></span> as layer data through the two typeclasses <span class="inlinecode"><a class="idref" href="liblayers.simrel.AbstractData.html#AbstractDataOps"><span class="id" title="record">AbstractDataOps</span></a></span> and
      <span class="inlinecode"><a class="idref" href="liblayers.simrel.AbstractData.html#AbstractData"><span class="id" title="record">AbstractData</span></a></span>.

<div class="paragraph"> </div>

      <span class="inlinecode"><a class="idref" href="liblayers.simrel.AbstractData.html#AbstractDataOps"><span class="id" title="record">AbstractDataOps</span></a></span> requires several fields. First, an initial element of
      the desired type (<span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#unit"><span class="id" title="inductive">unit</span></a></span> in our case). The other fields are predicates
      and invariants that we can simply instantiate with <span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#True"><span class="id" title="inductive">True</span></a></span> predicates for
      the moment.

<div class="paragraph"> </div>

      The field <span class="inlinecode"><a class="idref" href="liblayers.simrel.AbstractData.html#data_inv"><span class="id" title="projection">data_inv</span></a></span> specifies an invariant of the abstract data that
      must be preserved by all operations on abstract data.

<div class="paragraph"> </div>

      The field <span class="inlinecode"><a class="idref" href="liblayers.simrel.AbstractData.html#data_inject"><span class="id" title="projection">data_inject</span></a></span> specifies how data is injected, i.e. how
      injections relate these abstract data, in a manner close to CompCert's
      <span class="inlinecode"><span class="id" title="var">val_inject</span></span>. The only time this begins to get interesting is when you
      are dealing with pointers. 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Instance</span> <a name="base_data_ops"><span class="id" title="instance">base_data_ops</span></a> : <a class="idref" href="liblayers.simrel.AbstractData.html#AbstractDataOps"><span class="id" title="class">AbstractDataOps</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#unit"><span class="id" title="inductive">unit</span></a> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{|<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="liblayers.simrel.AbstractData.html#Build_AbstractDataOps"><span class="id" title="constructor">init_data</span></a> <a class="idref" href="liblayers.simrel.AbstractData.html#Build_AbstractDataOps"><span class="id" title="constructor">:=</span></a> <a class="idref" href="liblayers.simrel.AbstractData.html#Build_AbstractDataOps"><span class="id" title="constructor">tt</span></a><a class="idref" href="liblayers.simrel.AbstractData.html#Build_AbstractDataOps"><span class="id" title="constructor">;</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="liblayers.simrel.AbstractData.html#Build_AbstractDataOps"><span class="id" title="constructor">data_inv</span></a> <a class="idref" href="liblayers.simrel.AbstractData.html#Build_AbstractDataOps"><span class="id" title="constructor">:=</span></a> <span class="id" title="keyword">fun</span> <a class="idref" href="liblayers.simrel.AbstractData.html#Build_AbstractDataOps"><span class="id" title="constructor">_</span></a> <a class="idref" href="liblayers.simrel.AbstractData.html#Build_AbstractDataOps"><span class="id" title="constructor">⇒</span></a> <a class="idref" href="liblayers.simrel.AbstractData.html#Build_AbstractDataOps"><span class="id" title="constructor">True</span></a><a class="idref" href="liblayers.simrel.AbstractData.html#Build_AbstractDataOps"><span class="id" title="constructor">;</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="liblayers.simrel.AbstractData.html#Build_AbstractDataOps"><span class="id" title="constructor">data_inject</span></a> <a class="idref" href="liblayers.simrel.AbstractData.html#Build_AbstractDataOps"><span class="id" title="constructor">:=</span></a> <span class="id" title="keyword">fun</span> <a class="idref" href="liblayers.simrel.AbstractData.html#Build_AbstractDataOps"><span class="id" title="constructor">_</span></a> <a class="idref" href="liblayers.simrel.AbstractData.html#Build_AbstractDataOps"><span class="id" title="constructor">_</span></a> <a class="idref" href="liblayers.simrel.AbstractData.html#Build_AbstractDataOps"><span class="id" title="constructor">_</span></a> <a class="idref" href="liblayers.simrel.AbstractData.html#Build_AbstractDataOps"><span class="id" title="constructor">⇒</span></a> <a class="idref" href="liblayers.simrel.AbstractData.html#Build_AbstractDataOps"><span class="id" title="constructor">True</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|}.<br/>

<br/>
</div>

<div class="doc">
Now, we prove some properties of the aforementioned predicates. This is
       trivial in our case since we chose <span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#True"><span class="id" title="inductive">True</span></a></span>. 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Instance</span> <a name="base_data"><span class="id" title="instance">base_data</span></a> : <a class="idref" href="liblayers.simrel.AbstractData.html#AbstractData"><span class="id" title="class">AbstractData</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#unit"><span class="id" title="inductive">unit</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">repeat</span> <span class="id" title="tactic">constructor</span>. <span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
We now pack those into a <span class="inlinecode"><a class="idref" href="liblayers.simrel.AbstractData.html#layerdata"><span class="id" title="record">layerdata</span></a></span> record. 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <a name="base_layerdata"><span class="id" title="definition">base_layerdata</span></a> : <a class="idref" href="liblayers.simrel.AbstractData.html#layerdata"><span class="id" title="record">layerdata</span></a> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{|<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="liblayers.simrel.AbstractData.html#ldata"><span class="id" title="constructor">ldata_type</span></a> <a class="idref" href="liblayers.simrel.AbstractData.html#ldata"><span class="id" title="constructor">:=</span></a> <a class="idref" href="liblayers.simrel.AbstractData.html#ldata"><span class="id" title="constructor">unit</span></a><a class="idref" href="liblayers.simrel.AbstractData.html#ldata"><span class="id" title="constructor">;</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="liblayers.simrel.AbstractData.html#ldata"><span class="id" title="constructor">ldata_ops</span></a>  <a class="idref" href="liblayers.simrel.AbstractData.html#ldata"><span class="id" title="constructor">:=</span></a> <a class="idref" href="liblayers.simrel.AbstractData.html#ldata"><span class="id" title="constructor">base_data_ops</span></a><a class="idref" href="liblayers.simrel.AbstractData.html#ldata"><span class="id" title="constructor">;</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="liblayers.simrel.AbstractData.html#ldata"><span class="id" title="constructor">ldata_prf</span></a>  <a class="idref" href="liblayers.simrel.AbstractData.html#ldata"><span class="id" title="constructor">:=</span></a> <a class="idref" href="liblayers.simrel.AbstractData.html#ldata"><span class="id" title="constructor">base_data</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|}.<br/>

<br/>
</div>

<div class="doc">
We can now define the underlay, <span class="inlinecode"><a class="idref" href="tutorial.stack.Counter.html#base_L"><span class="id" title="definition">base_L</span></a></span>, as the empty layer
      interface. 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <a name="base_L"><span class="id" title="definition">base_L</span></a> : <a class="idref" href="liblayers.compcertx.CPrimitives.html#clayer"><span class="id" title="abbreviation">clayer</span></a> <a class="idref" href="tutorial.stack.Counter.html#base_layerdata"><span class="id" title="definition">base_layerdata</span></a> := <a class="idref" href="liblayers.logic.Structures.html#1bcfff782645e550303b44d1d50df7a5"><span class="id" title="notation">∅</span></a>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab693"></a><h3 class="section">Overlay</h3>

<div class="paragraph"> </div>

 We want our overlay to abstract a counter, hence our abstract data will
      consist of a record <span class="inlinecode"><a class="idref" href="tutorial.stack.Counter.html#counter_data"><span class="id" title="record">counter_data</span></a></span> that encapsulates this counter as a
      natural number. Then, we declare this abstract data as appropriate layer
      data, as before. 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Record</span> <a name="counter_data"><span class="id" title="record">counter_data</span></a> : <span class="id" title="keyword">Type</span> := { <a name="counter"><span class="id" title="projection">counter</span></a>: <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> }.<br/>

<br/>
</div>

<div class="doc">
We initialize <span class="inlinecode"><a class="idref" href="tutorial.stack.Counter.html#counter"><span class="id" title="projection">counter</span></a></span> to <span class="inlinecode">0</span> and require that it is never greater
      than <span class="inlinecode"><a class="idref" href="tutorial.stack.Counter.html#MAX_COUNTER"><span class="id" title="definition">MAX_COUNTER</span></a></span>. 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Instance</span> <a name="counter_data_data_ops"><span class="id" title="instance">counter_data_data_ops</span></a> : <a class="idref" href="liblayers.simrel.AbstractData.html#AbstractDataOps"><span class="id" title="class">AbstractDataOps</span></a> <a class="idref" href="tutorial.stack.Counter.html#counter_data"><span class="id" title="record">counter_data</span></a> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{|<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="liblayers.simrel.AbstractData.html#Build_AbstractDataOps"><span class="id" title="constructor">init_data</span></a> <a class="idref" href="liblayers.simrel.AbstractData.html#Build_AbstractDataOps"><span class="id" title="constructor">:=</span></a> <a class="idref" href="liblayers.simrel.AbstractData.html#Build_AbstractDataOps"><span class="id" title="constructor">{|</span></a> <a class="idref" href="liblayers.simrel.AbstractData.html#Build_AbstractDataOps"><span class="id" title="constructor">counter</span></a> <a class="idref" href="liblayers.simrel.AbstractData.html#Build_AbstractDataOps"><span class="id" title="constructor">:=</span></a> <a class="idref" href="liblayers.simrel.AbstractData.html#Build_AbstractDataOps"><span class="id" title="constructor">0</span></a> <a class="idref" href="liblayers.simrel.AbstractData.html#Build_AbstractDataOps"><span class="id" title="constructor">|};</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="liblayers.simrel.AbstractData.html#Build_AbstractDataOps"><span class="id" title="constructor">data_inv</span></a> <a class="idref" href="liblayers.simrel.AbstractData.html#Build_AbstractDataOps"><span class="id" title="constructor">:=</span></a> <span class="id" title="keyword">fun</span> <a class="idref" href="liblayers.simrel.AbstractData.html#Build_AbstractDataOps"><span class="id" title="constructor">d</span></a> <a class="idref" href="liblayers.simrel.AbstractData.html#Build_AbstractDataOps"><span class="id" title="constructor">⇒</span></a> <a class="idref" href="liblayers.simrel.AbstractData.html#Build_AbstractDataOps"><span class="id" title="constructor">(</span></a><a class="idref" href="liblayers.simrel.AbstractData.html#Build_AbstractDataOps"><span class="id" title="constructor">counter</span></a> <a class="idref" href="liblayers.simrel.AbstractData.html#Build_AbstractDataOps"><span class="id" title="constructor">d</span></a> <a class="idref" href="liblayers.simrel.AbstractData.html#Build_AbstractDataOps"><span class="id" title="constructor">≤</span></a> <a class="idref" href="liblayers.simrel.AbstractData.html#Build_AbstractDataOps"><span class="id" title="constructor">MAX_COUNTER</span></a><a class="idref" href="liblayers.simrel.AbstractData.html#Build_AbstractDataOps"><span class="id" title="constructor">)%</span></a><a class="idref" href="liblayers.simrel.AbstractData.html#Build_AbstractDataOps"><span class="id" title="constructor">nat</span></a><a class="idref" href="liblayers.simrel.AbstractData.html#Build_AbstractDataOps"><span class="id" title="constructor">;</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="liblayers.simrel.AbstractData.html#Build_AbstractDataOps"><span class="id" title="constructor">data_inject</span></a> <a class="idref" href="liblayers.simrel.AbstractData.html#Build_AbstractDataOps"><span class="id" title="constructor">:=</span></a> <span class="id" title="keyword">fun</span> <a class="idref" href="liblayers.simrel.AbstractData.html#Build_AbstractDataOps"><span class="id" title="constructor">f</span></a> <a class="idref" href="liblayers.simrel.AbstractData.html#Build_AbstractDataOps"><span class="id" title="constructor">d1</span></a> <a class="idref" href="liblayers.simrel.AbstractData.html#Build_AbstractDataOps"><span class="id" title="constructor">d2</span></a> <a class="idref" href="liblayers.simrel.AbstractData.html#Build_AbstractDataOps"><span class="id" title="constructor">⇒</span></a> <a class="idref" href="liblayers.simrel.AbstractData.html#Build_AbstractDataOps"><span class="id" title="constructor">True</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|}.<br/>

<br/>
</div>

<div class="doc">
This time we must prove that the initial abstract state (<span class="inlinecode"><a class="idref" href="tutorial.stack.Counter.html#counter"><span class="id" title="projection">counter</span></a></span> <span class="inlinecode">=</span> <span class="inlinecode">0</span>)
      satisfies the invariants (<span class="inlinecode">0</span> <span class="inlinecode">≤</span> <span class="inlinecode"><a class="idref" href="tutorial.stack.Counter.html#MAX_COUNTER"><span class="id" title="definition">MAX_COUNTER</span></a></span>). 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Instance</span> <a name="counter_data_data"><span class="id" title="instance">counter_data_data</span></a> : <a class="idref" href="liblayers.simrel.AbstractData.html#AbstractData"><span class="id" title="class">AbstractData</span></a> <a class="idref" href="tutorial.stack.Counter.html#counter_data"><span class="id" title="record">counter_data</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">repeat</span> <span class="id" title="tactic">constructor</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">cbv</span>; <span class="id" title="tactic">omega</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Defined</span>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <a name="counter_layerdata"><span class="id" title="definition">counter_layerdata</span></a> : <a class="idref" href="liblayers.simrel.AbstractData.html#layerdata"><span class="id" title="record">layerdata</span></a> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{|<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="liblayers.simrel.AbstractData.html#ldata"><span class="id" title="constructor">ldata_type</span></a> <a class="idref" href="liblayers.simrel.AbstractData.html#ldata"><span class="id" title="constructor">:=</span></a> <a class="idref" href="liblayers.simrel.AbstractData.html#ldata"><span class="id" title="constructor">counter_data</span></a><a class="idref" href="liblayers.simrel.AbstractData.html#ldata"><span class="id" title="constructor">;</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="liblayers.simrel.AbstractData.html#ldata"><span class="id" title="constructor">ldata_ops</span></a>  <a class="idref" href="liblayers.simrel.AbstractData.html#ldata"><span class="id" title="constructor">:=</span></a> <a class="idref" href="liblayers.simrel.AbstractData.html#ldata"><span class="id" title="constructor">counter_data_data_ops</span></a><a class="idref" href="liblayers.simrel.AbstractData.html#ldata"><span class="id" title="constructor">;</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="liblayers.simrel.AbstractData.html#ldata"><span class="id" title="constructor">ldata_prf</span></a>  <a class="idref" href="liblayers.simrel.AbstractData.html#ldata"><span class="id" title="constructor">:=</span></a> <a class="idref" href="liblayers.simrel.AbstractData.html#ldata"><span class="id" title="constructor">counter_data_data</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|}.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">End</span> <a class="idref" href="tutorial.stack.Counter.html#Counter.AbsData"><span class="id" title="section">AbsData</span></a>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab694"></a><h2 class="section">High Level Specifications</h2>

</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="keyword">Section</span> <a name="Counter.HighSpec"><span class="id" title="section">HighSpec</span></a>.<br/>
</div>

<div class="doc">
We now specify the behaviour of the primitives we will expose through
      our new layer. These are expressed as functions from <span class="inlinecode"><a class="idref" href="tutorial.stack.Counter.html#counter_data"><span class="id" title="record">counter_data</span></a></span> to
      some other type. 
<div class="paragraph"> </div>

 <span class="inlinecode"><a class="idref" href="tutorial.stack.Counter.html#get_counter"><span class="id" title="definition">get_counter</span></a></span> simply returns the current value of the counter. 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <a name="get_counter_high_spec"><span class="id" title="definition">get_counter_high_spec</span></a> (<span class="id" title="var">abs</span>: <a class="idref" href="tutorial.stack.Counter.html#counter_layerdata"><span class="id" title="definition">counter_layerdata</span></a>) : <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="tutorial.stack.Counter.html#counter"><span class="id" title="projection">counter</span></a> <a class="idref" href="tutorial.stack.Counter.html#abs"><span class="id" title="variable">abs</span></a>.<br/>

<br/>
</div>

<div class="doc">
We prove that our high level specs preserve the invariant
      (<span class="inlinecode"><a class="idref" href="tutorial.stack.Counter.html#counter"><span class="id" title="projection">counter</span></a></span> <span class="inlinecode">≤</span> <span class="inlinecode"><a class="idref" href="tutorial.stack.Counter.html#MAX_COUNTER"><span class="id" title="definition">MAX_COUNTER</span></a></span>) by declaring them as instances of
      <span class="inlinecode"><a class="idref" href="liblayers.compcertx.CGenSem.html#GenSemPreservesInvariant"><span class="id" title="record">GenSemPreservesInvariant</span></a></span>. This is important so we can make use of
      the invariant later on in the code or refinement proofs. In particular,
      the code proof of the <span class="inlinecode"><a class="idref" href="tutorial.stack.Stack.html#pop"><span class="id" title="definition">pop</span></a></span> primitive in the Stack layer relies on this
      fact. 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Global Instance</span> <a name="get_counter_preserves_invariant"><span class="id" title="instance">get_counter_preserves_invariant</span></a> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="liblayers.compcertx.CGenSem.html#GenSemPreservesInvariant"><span class="id" title="class">GenSemPreservesInvariant</span></a> <a class="idref" href="tutorial.stack.Counter.html#counter_layerdata"><span class="id" title="definition">counter_layerdata</span></a> <a class="idref" href="tutorial.stack.Counter.html#get_counter_high_spec"><span class="id" title="definition">get_counter_high_spec</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">split</span>; <span class="id" title="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> ? ? ? ? ? <span class="id" title="var">Hsem</span> ? ?.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">inv</span> <span class="id" title="var">Hsem</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">inv_monad</span> <span class="id" title="var">H2</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">inv</span> <span class="id" title="var">H2</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
To incorporate this specification in a layer interface, we must wrap it
      as a <span class="inlinecode"><a class="idref" href="liblayers.compcertx.CPrimitives.html#cprimitive"><span class="id" title="record">cprimitive</span></a></span>. A <span class="inlinecode"><a class="idref" href="liblayers.compcertx.CPrimitives.html#cprimitive"><span class="id" title="record">cprimitive</span></a></span> is merely a relation between inputs
      (list of arguments and starting memory state) and outputs (return value
      and resulting memory state), along with some properties. The <span class="inlinecode"><a class="idref" href="liblayers.compcertx.CGenSem.html#cgensem"><span class="id" title="definition">cgensem</span></a></span>
      function automatically discharges some proof obligations for us, provided
      that the specification is of a certain form (<span class="inlinecode"><span class="id" title="var">SemOf</span></span>). 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <a name="get_counter_high_sem"><span class="id" title="definition">get_counter_high_sem</span></a> : <a class="idref" href="liblayers.compcertx.CPrimitives.html#cprimitive"><span class="id" title="record">cprimitive</span></a> <a class="idref" href="tutorial.stack.Counter.html#counter_layerdata"><span class="id" title="definition">counter_layerdata</span></a> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="liblayers.compcertx.CGenSem.html#cgensem"><span class="id" title="definition">cgensem</span></a> <a class="idref" href="tutorial.stack.Counter.html#counter_layerdata"><span class="id" title="definition">counter_layerdata</span></a> <a class="idref" href="tutorial.stack.Counter.html#get_counter_high_spec"><span class="id" title="definition">get_counter_high_spec</span></a>.<br/>

<br/>
</div>

<div class="doc">
We can then define a layer consisting of just the <span class="inlinecode"><a class="idref" href="tutorial.stack.Counter.html#get_counter"><span class="id" title="definition">get_counter</span></a></span>
      primitive. 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <a name="get_counter_layer"><span class="id" title="definition">get_counter_layer</span></a> : <a class="idref" href="liblayers.compcertx.CPrimitives.html#clayer"><span class="id" title="abbreviation">clayer</span></a> <a class="idref" href="tutorial.stack.Counter.html#counter_layerdata"><span class="id" title="definition">counter_layerdata</span></a> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="tutorial.stack.Counter.html#get_counter"><span class="id" title="definition">get_counter</span></a> <a class="idref" href="liblayers.logic.Structures.html#33228780c4c171a6131f9e6e62ea2dd4"><span class="id" title="notation">↦</span></a> <a class="idref" href="tutorial.stack.Counter.html#get_counter_high_sem"><span class="id" title="definition">get_counter_high_sem</span></a>.<br/>

<br/>
</div>

<div class="doc">
Because <span class="inlinecode"><a class="idref" href="tutorial.stack.Counter.html#incr_counter"><span class="id" title="definition">incr_counter</span></a></span> can fail, it returns a value of type
      <span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#option"><span class="id" title="inductive">option</span></a></span> <span class="inlinecode">(<a class="idref" href="tutorial.stack.Counter.html#counter_data"><span class="id" title="record">counter_data</span></a></span> <span class="inlinecode">×</span> <span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>)</span>. In the case where the counter is not
      already at its maximum value it returns a new abstract data with the
      incremented counter, along with the value of the incremented counter.
      Otherwise it returns <span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#None"><span class="id" title="constructor">None</span></a></span>, representing an error. 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <a name="incr_counter_high_spec"><span class="id" title="definition">incr_counter_high_spec</span></a> (<span class="id" title="var">abs</span>: <a class="idref" href="tutorial.stack.Counter.html#counter_layerdata"><span class="id" title="definition">counter_layerdata</span></a>) :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#option"><span class="id" title="inductive">option</span></a> (<a class="idref" href="tutorial.stack.Counter.html#counter_layerdata"><span class="id" title="definition">counter_layerdata</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">×</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>) :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">if</span> <a class="idref" href="liblayers.lib.Decision.html#decide"><span class="id" title="definition">decide</span></a> (<a class="idref" href="tutorial.stack.Counter.html#counter"><span class="id" title="projection">counter</span></a> <a class="idref" href="tutorial.stack.Counter.html#abs"><span class="id" title="variable">abs</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Peano.html#989c98e7ddd65d5bf37c334ff2076de8"><span class="id" title="notation">&lt;</span></a> <a class="idref" href="tutorial.stack.Counter.html#MAX_COUNTER"><span class="id" title="definition">MAX_COUNTER</span></a>)%<span class="id" title="var">nat</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">then</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#Some"><span class="id" title="constructor">Some</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">({|</span></a> <a class="idref" href="tutorial.stack.Counter.html#Build_counter_data"><span class="id" title="constructor">counter</span></a> <a class="idref" href="tutorial.stack.Counter.html#Build_counter_data"><span class="id" title="constructor">:=</span></a> <a class="idref" href="tutorial.stack.Counter.html#Build_counter_data"><span class="id" title="constructor">counter</span></a> <a class="idref" href="tutorial.stack.Counter.html#Build_counter_data"><span class="id" title="constructor">abs</span></a> <a class="idref" href="tutorial.stack.Counter.html#Build_counter_data"><span class="id" title="constructor">+</span></a> <a class="idref" href="tutorial.stack.Counter.html#Build_counter_data"><span class="id" title="constructor">1</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">|},</span></a> (<a class="idref" href="tutorial.stack.Counter.html#counter"><span class="id" title="projection">counter</span></a> <a class="idref" href="tutorial.stack.Counter.html#abs"><span class="id" title="variable">abs</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Peano.html#b3eea360671e1b32b18a26e15b3aace3"><span class="id" title="notation">+</span></a> 1)%<span class="id" title="var">nat</span><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">)</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">else</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#None"><span class="id" title="constructor">None</span></a>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Global Instance</span> <a name="incr_counter_preserves_invariant"><span class="id" title="instance">incr_counter_preserves_invariant</span></a> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="liblayers.compcertx.CGenSem.html#GenSemPreservesInvariant"><span class="id" title="class">GenSemPreservesInvariant</span></a> <a class="idref" href="tutorial.stack.Counter.html#counter_layerdata"><span class="id" title="definition">counter_layerdata</span></a> <a class="idref" href="tutorial.stack.Counter.html#incr_counter_high_spec"><span class="id" title="definition">incr_counter_high_spec</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">split</span>; <span class="id" title="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> ? ? ? ? ? <span class="id" title="var">Hsem</span> ? ?.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">inv_generic_sem</span> <span class="id" title="var">Hsem</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">inv_monad</span> <span class="id" title="var">H2</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <a class="idref" href="tutorial.stack.Counter.html#incr_counter_high_spec"><span class="id" title="definition">incr_counter_high_spec</span></a> <span class="id" title="keyword">in</span> <span class="id" title="var">H4</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> (<a class="idref" href="liblayers.lib.Decision.html#decide"><span class="id" title="definition">decide</span></a> (<a class="idref" href="tutorial.stack.Counter.html#counter"><span class="id" title="projection">counter</span></a> <span class="id" title="var">d</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Peano.html#989c98e7ddd65d5bf37c334ff2076de8"><span class="id" title="notation">&lt;</span></a> <a class="idref" href="tutorial.stack.Counter.html#MAX_COUNTER"><span class="id" title="definition">MAX_COUNTER</span></a>)%<span class="id" title="var">nat</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" title="var">inv</span> <span class="id" title="var">H4</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">cbn</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">omega</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" title="tactic">discriminate</span> <span class="id" title="var">H4</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Defined</span>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <a name="incr_counter_high_sem"><span class="id" title="definition">incr_counter_high_sem</span></a> : <a class="idref" href="liblayers.compcertx.CPrimitives.html#cprimitive"><span class="id" title="record">cprimitive</span></a> <a class="idref" href="tutorial.stack.Counter.html#counter_layerdata"><span class="id" title="definition">counter_layerdata</span></a> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="liblayers.compcertx.CGenSem.html#cgensem"><span class="id" title="definition">cgensem</span></a> <a class="idref" href="tutorial.stack.Counter.html#counter_layerdata"><span class="id" title="definition">counter_layerdata</span></a> <a class="idref" href="tutorial.stack.Counter.html#incr_counter_high_spec"><span class="id" title="definition">incr_counter_high_spec</span></a>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <a name="incr_counter_layer"><span class="id" title="definition">incr_counter_layer</span></a> : <a class="idref" href="liblayers.compcertx.CPrimitives.html#clayer"><span class="id" title="abbreviation">clayer</span></a> <a class="idref" href="tutorial.stack.Counter.html#counter_layerdata"><span class="id" title="definition">counter_layerdata</span></a> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="tutorial.stack.Counter.html#incr_counter"><span class="id" title="definition">incr_counter</span></a> <a class="idref" href="liblayers.logic.Structures.html#33228780c4c171a6131f9e6e62ea2dd4"><span class="id" title="notation">↦</span></a> <a class="idref" href="tutorial.stack.Counter.html#incr_counter_high_sem"><span class="id" title="definition">incr_counter_high_sem</span></a>.<br/>

<br/>
</div>

<div class="doc">
<span class="inlinecode"><a class="idref" href="tutorial.stack.Counter.html#decr_counter"><span class="id" title="definition">decr_counter</span></a></span> is defined similarly to <span class="inlinecode"><a class="idref" href="tutorial.stack.Counter.html#incr_counter"><span class="id" title="definition">incr_counter</span></a></span>. 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <a name="decr_counter_high_spec"><span class="id" title="definition">decr_counter_high_spec</span></a> (<span class="id" title="var">abs</span>: <a class="idref" href="tutorial.stack.Counter.html#counter_layerdata"><span class="id" title="definition">counter_layerdata</span></a>) :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#option"><span class="id" title="inductive">option</span></a> (<a class="idref" href="tutorial.stack.Counter.html#counter_layerdata"><span class="id" title="definition">counter_layerdata</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">×</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>) :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">if</span> <a class="idref" href="liblayers.lib.Decision.html#decide"><span class="id" title="definition">decide</span></a> (0 <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Peano.html#989c98e7ddd65d5bf37c334ff2076de8"><span class="id" title="notation">&lt;</span></a> <a class="idref" href="tutorial.stack.Counter.html#counter"><span class="id" title="projection">counter</span></a> <a class="idref" href="tutorial.stack.Counter.html#abs"><span class="id" title="variable">abs</span></a>)%<span class="id" title="var">nat</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">then</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#Some"><span class="id" title="constructor">Some</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">({|</span></a> <a class="idref" href="tutorial.stack.Counter.html#Build_counter_data"><span class="id" title="constructor">counter</span></a> <a class="idref" href="tutorial.stack.Counter.html#Build_counter_data"><span class="id" title="constructor">:=</span></a> <a class="idref" href="tutorial.stack.Counter.html#Build_counter_data"><span class="id" title="constructor">counter</span></a> <a class="idref" href="tutorial.stack.Counter.html#Build_counter_data"><span class="id" title="constructor">abs</span></a> <a class="idref" href="tutorial.stack.Counter.html#Build_counter_data"><span class="id" title="constructor">-</span></a> <a class="idref" href="tutorial.stack.Counter.html#Build_counter_data"><span class="id" title="constructor">1</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">|},</span></a> (<a class="idref" href="tutorial.stack.Counter.html#counter"><span class="id" title="projection">counter</span></a> <a class="idref" href="tutorial.stack.Counter.html#abs"><span class="id" title="variable">abs</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Peano.html#9482aae3d3b06e249765c1225dbb8cbb"><span class="id" title="notation">-</span></a> 1)%<span class="id" title="var">nat</span><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">)</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">else</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#None"><span class="id" title="constructor">None</span></a>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Global Instance</span> <a name="decr_counter_preserves_invariant"><span class="id" title="instance">decr_counter_preserves_invariant</span></a> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="liblayers.compcertx.CGenSem.html#GenSemPreservesInvariant"><span class="id" title="class">GenSemPreservesInvariant</span></a> <a class="idref" href="tutorial.stack.Counter.html#counter_layerdata"><span class="id" title="definition">counter_layerdata</span></a> <a class="idref" href="tutorial.stack.Counter.html#decr_counter_high_spec"><span class="id" title="definition">decr_counter_high_spec</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>.<br/>
</div>

<div class="doc">
TUTORIAL: Prove that decr_counter preserves the layer invariant 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">Admitted</span>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <a name="decr_counter_high_sem"><span class="id" title="definition">decr_counter_high_sem</span></a> : <a class="idref" href="liblayers.compcertx.CPrimitives.html#cprimitive"><span class="id" title="record">cprimitive</span></a> <a class="idref" href="tutorial.stack.Counter.html#counter_layerdata"><span class="id" title="definition">counter_layerdata</span></a> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="liblayers.compcertx.CGenSem.html#cgensem"><span class="id" title="definition">cgensem</span></a> <a class="idref" href="tutorial.stack.Counter.html#counter_layerdata"><span class="id" title="definition">counter_layerdata</span></a> <a class="idref" href="tutorial.stack.Counter.html#decr_counter_high_spec"><span class="id" title="definition">decr_counter_high_spec</span></a>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <a name="decr_counter_layer"><span class="id" title="definition">decr_counter_layer</span></a> : <a class="idref" href="liblayers.compcertx.CPrimitives.html#clayer"><span class="id" title="abbreviation">clayer</span></a> <a class="idref" href="tutorial.stack.Counter.html#counter_layerdata"><span class="id" title="definition">counter_layerdata</span></a> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="tutorial.stack.Counter.html#decr_counter"><span class="id" title="definition">decr_counter</span></a> <a class="idref" href="liblayers.logic.Structures.html#33228780c4c171a6131f9e6e62ea2dd4"><span class="id" title="notation">↦</span></a> <a class="idref" href="tutorial.stack.Counter.html#decr_counter_high_sem"><span class="id" title="definition">decr_counter_high_sem</span></a>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">End</span> <a class="idref" href="tutorial.stack.Counter.html#Counter.HighSpec"><span class="id" title="section">HighSpec</span></a>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab695"></a><h2 class="section">Module Implementation</h2>

</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="keyword">Section</span> <a name="Counter.Code"><span class="id" title="section">Code</span></a>.<br/>
</div>

<div class="doc">
We now provide implementations of our primitives as Clight functions.
      Functions are encoded in records with their return type in field
      <span class="inlinecode"><a class="idref" href="compcert.cfrontend.Clight.html#fn_return"><span class="id" title="projection">fn_return</span></a></span>, the types of their parameters, local variables and temporary
      variables in <span class="inlinecode"><a class="idref" href="compcert.backend.CminorSel.html#fn_params"><span class="id" title="projection">fn_params</span></a></span>, <span class="inlinecode"><a class="idref" href="compcert.backend.CminorSel.html#fn_vars"><span class="id" title="projection">fn_vars</span></a></span> and <span class="inlinecode"><a class="idref" href="compcert.cfrontend.Clight.html#fn_temps"><span class="id" title="projection">fn_temps</span></a></span> respectively, and the
      function body in <span class="inlinecode"><a class="idref" href="compcert.backend.CminorSel.html#fn_body"><span class="id" title="projection">fn_body</span></a></span>.

<div class="paragraph"> </div>

      The difference between local and temporaries variables is that the former
      are stored inside the memory while the latter are part of an abstract
      semantic environment which is not part of the memory.

<div class="paragraph"> </div>

      We omit a description of the field <span class="inlinecode"><a class="idref" href="compcert.cfrontend.Clight.html#fn_callconv"><span class="id" title="projection">fn_callconv</span></a></span> here, as it is not
      relevant to this tutorial.

<div class="paragraph"> </div>

      The corresponding C code for each function is also provided. 
<div class="paragraph"> </div>

 <span class="inlinecode"><a class="idref" href="tutorial.stack.Counter.html#f_get_counter"><span class="id" title="definition">f_get_counter</span></a></span> is implemented as expected. 
<div class="paragraph"> </div>

<pre>
int get_counter() {
  return COUNTER;
}
</pre>
 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <a name="f_get_counter"><span class="id" title="definition">f_get_counter</span></a> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{|<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">fn_return</span></a> <a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">:=</span></a> <a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">tuint</span></a><a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">;</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">fn_callconv</span></a> <a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">:=</span></a> <a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">cc_default</span></a><a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">;</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">fn_params</span></a> <a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">:=</span></a> <a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">nil</span></a><a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">;</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">fn_vars</span></a> <a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">:=</span></a> <a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">nil</span></a><a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">;</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">fn_temps</span></a> <a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">:=</span></a> <a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">nil</span></a><a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">;</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">fn_body</span></a> <a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">:=</span></a> <a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">Sreturn</span></a> <a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">(</span></a><a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">Some</span></a> <a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">(</span></a><a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">Evar</span></a> <a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">COUNTER</span></a> <a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">tuint</span></a><a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">))</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|}.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Program Definition</span> <a name="inlinable_f_get_counter"><span class="id" title="definition">inlinable_f_get_counter</span></a> : <a class="idref" href="liblayers.compcertx.ClightModules.html#function"><span class="id" title="abbreviation">function</span></a> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="liblayers.compcertx.ClightModules.html#inline"><span class="id" title="definition">inline</span></a> <a class="idref" href="tutorial.stack.Counter.html#f_get_counter"><span class="id" title="definition">f_get_counter</span></a> <span class="id" title="var">_</span>.<br/>

<br/>
</div>

<div class="doc">
<span class="inlinecode"><a class="idref" href="tutorial.stack.Counter.html#f_incr_counter"><span class="id" title="definition">f_incr_counter</span></a></span> handles the case where <span class="inlinecode"><a class="idref" href="tutorial.stack.Counter.html#counter"><span class="id" title="projection">counter</span></a></span> <span class="inlinecode">&lt;</span> <span class="inlinecode"><a class="idref" href="tutorial.stack.Counter.html#MAX_COUNTER"><span class="id" title="definition">MAX_COUNTER</span></a></span> as
      expected. It handles the failure case by not incrementing <span class="inlinecode"><a class="idref" href="tutorial.stack.Counter.html#COUNTER"><span class="id" title="definition">COUNTER</span></a></span> and
      returning an error code represented by <span class="inlinecode"><a class="idref" href="tutorial.stack.Counter.html#MAX_COUNTER"><span class="id" title="definition">MAX_COUNTER</span></a></span> <span class="inlinecode">+</span> <span class="inlinecode">1</span>. 
<div class="paragraph"> </div>

<pre>
int incr_counter() {
  if (counter &lt; MAX_COUNTER) {
    COUNTER = COUNTER + 1;
    return COUNTER;
  } else {
    return MAX_COUNTER + 1;
  }
}
</pre>
 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <a name="f_incr_counter"><span class="id" title="definition">f_incr_counter</span></a> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{|<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">fn_return</span></a> <a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">:=</span></a> <a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">tuint</span></a><a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">;</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">fn_callconv</span></a> <a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">:=</span></a> <a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">cc_default</span></a><a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">;</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">fn_params</span></a> <a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">:=</span></a> <a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">nil</span></a><a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">;</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">fn_vars</span></a> <a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">:=</span></a> <a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">nil</span></a><a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">;</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">fn_temps</span></a> <a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">:=</span></a> <a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">nil</span></a><a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">;</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">fn_body</span></a> <a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">:=</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">Sifthenelse</span></a> <a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">(</span></a><a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">Ebinop</span></a> <a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">Olt</span></a> <a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">(</span></a><a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">Evar</span></a> <a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">COUNTER</span></a> <a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">tuint</span></a><a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">)</span></a> <a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">(</span></a><a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">Econst_int</span></a> <a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">MAX_COUNTER_i</span></a> <a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">tuint</span></a><a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">)</span></a> <a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">tuint</span></a><a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">)</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">(</span></a><a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">Ssequence</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">(</span></a><a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">Sassign</span></a> <a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">(</span></a><a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">Evar</span></a> <a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">COUNTER</span></a> <a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">tuint</span></a><a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">)</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">(</span></a><a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">Ebinop</span></a> <a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">Oadd</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">(</span></a><a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">Evar</span></a> <a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">COUNTER</span></a> <a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">tuint</span></a><a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">)</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">(</span></a><a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">Econst_int</span></a> <a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">(</span></a><a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">Int.repr</span></a> <a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">1)</span></a> <a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">tuint</span></a><a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">)</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">tuint</span></a><a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">))</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">(</span></a><a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">Sreturn</span></a> <a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">(</span></a><a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">Some</span></a> <a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">(</span></a><a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">Evar</span></a> <a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">COUNTER</span></a> <a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">tuint</span></a><a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">))))</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">(</span></a><a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">Sreturn</span></a> <a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">(</span></a><a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">Some</span></a> <a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">(</span></a><a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">Ebinop</span></a> <a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">Oadd</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">(</span></a><a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">Econst_int</span></a> <a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">MAX_COUNTER_i</span></a> <a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">tuint</span></a><a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">)</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">(</span></a><a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">Econst_int</span></a> <a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">(</span></a><a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">Int.repr</span></a> <a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">1)</span></a> <a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">tuint</span></a><a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">)</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">tuint</span></a><a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">)))</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|}.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Program Definition</span> <a name="inlinable_f_incr_counter"><span class="id" title="definition">inlinable_f_incr_counter</span></a> : <a class="idref" href="liblayers.compcertx.ClightModules.html#function"><span class="id" title="abbreviation">function</span></a> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="liblayers.compcertx.ClightModules.html#inline"><span class="id" title="definition">inline</span></a> <a class="idref" href="tutorial.stack.Counter.html#f_incr_counter"><span class="id" title="definition">f_incr_counter</span></a> <span class="id" title="var">_</span>.<br/>

<br/>
</div>

<div class="doc">
<span class="inlinecode"><a class="idref" href="tutorial.stack.Counter.html#f_decr_counter"><span class="id" title="definition">f_decr_counter</span></a></span> handles failure in the same way as
      <span class="inlinecode"><a class="idref" href="tutorial.stack.Counter.html#f_incr_counter"><span class="id" title="definition">f_incr_counter</span></a></span>. 
<div class="paragraph"> </div>

<pre>
int decr_counter() {
  if (0 &lt; counter) {
    COUNTER = COUNTER - 1;
    return COUNTER;
  } else {
    return MAX_COUNTER + 1;
  }
}
</pre>
 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <a name="f_decr_counter"><span class="id" title="definition">f_decr_counter</span></a> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{|<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">fn_return</span></a> <a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">:=</span></a> <a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">tuint</span></a><a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">;</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">fn_callconv</span></a> <a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">:=</span></a> <a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">cc_default</span></a><a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">;</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">fn_params</span></a> <a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">:=</span></a> <a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">nil</span></a><a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">;</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">fn_vars</span></a> <a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">:=</span></a> <a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">nil</span></a><a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">;</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">fn_temps</span></a> <a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">:=</span></a> <a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">nil</span></a><a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">;</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">fn_body</span></a> <a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">:=</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">Sifthenelse</span></a> <a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">(</span></a><a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">Ebinop</span></a> <a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">Olt</span></a> <a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">(</span></a><a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">Econst_int</span></a> <a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">(</span></a><a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">Int.repr</span></a> <a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">0)</span></a> <a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">tuint</span></a><a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">)</span></a> <a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">(</span></a><a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">Evar</span></a> <a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">COUNTER</span></a> <a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">tuint</span></a><a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">)</span></a> <a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">tuint</span></a><a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">)</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">(</span></a><a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">Ssequence</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">(</span></a><a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">Sassign</span></a> <a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">(</span></a><a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">Evar</span></a> <a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">COUNTER</span></a> <a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">tuint</span></a><a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">)</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">(</span></a><a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">Ebinop</span></a> <a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">Osub</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">(</span></a><a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">Evar</span></a> <a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">COUNTER</span></a> <a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">tuint</span></a><a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">)</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">(</span></a><a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">Econst_int</span></a> <a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">(</span></a><a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">Int.repr</span></a> <a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">1)</span></a> <a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">tuint</span></a><a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">)</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">tuint</span></a><a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">))</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">(</span></a><a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">Sreturn</span></a> <a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">(</span></a><a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">Some</span></a> <a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">(</span></a><a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">Evar</span></a> <a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">COUNTER</span></a> <a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">tuint</span></a><a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">))))</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">(</span></a><a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">Sreturn</span></a> <a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">(</span></a><a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">Some</span></a> <a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">(</span></a><a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">Ebinop</span></a> <a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">Oadd</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">(</span></a><a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">Econst_int</span></a> <a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">MAX_COUNTER_i</span></a> <a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">tuint</span></a><a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">)</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">(</span></a><a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">Econst_int</span></a> <a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">(</span></a><a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">Int.repr</span></a> <a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">1)</span></a> <a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">tuint</span></a><a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">)</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">tuint</span></a><a class="idref" href="compcert.cfrontend.Clight.html#mkfunction"><span class="id" title="constructor">)))</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|}.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Program Definition</span> <a name="inlinable_f_decr_counter"><span class="id" title="definition">inlinable_f_decr_counter</span></a> : <a class="idref" href="liblayers.compcertx.ClightModules.html#function"><span class="id" title="abbreviation">function</span></a> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="liblayers.compcertx.ClightModules.html#inline"><span class="id" title="definition">inline</span></a> <a class="idref" href="tutorial.stack.Counter.html#f_decr_counter"><span class="id" title="definition">f_decr_counter</span></a> <span class="id" title="var">_</span>.<br/>

<br/>
</div>

<div class="doc">
Similar to the layers we defined for each of the primitive high specs,
      we can also define modules consisting of the Clight implementations of
      the primitives. 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <a name="Mget"><span class="id" title="definition">Mget</span></a> : <a class="idref" href="liblayers.compcertx.ClightModules.html#cmodule"><span class="id" title="abbreviation">cmodule</span></a> := <a class="idref" href="tutorial.stack.Counter.html#get_counter"><span class="id" title="definition">get_counter</span></a> <a class="idref" href="liblayers.logic.Structures.html#33228780c4c171a6131f9e6e62ea2dd4"><span class="id" title="notation">↦</span></a> <a class="idref" href="tutorial.stack.Counter.html#inlinable_f_get_counter"><span class="id" title="definition">inlinable_f_get_counter</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <a name="Mincr"><span class="id" title="definition">Mincr</span></a> : <a class="idref" href="liblayers.compcertx.ClightModules.html#cmodule"><span class="id" title="abbreviation">cmodule</span></a> := <a class="idref" href="tutorial.stack.Counter.html#incr_counter"><span class="id" title="definition">incr_counter</span></a> <a class="idref" href="liblayers.logic.Structures.html#33228780c4c171a6131f9e6e62ea2dd4"><span class="id" title="notation">↦</span></a> <a class="idref" href="tutorial.stack.Counter.html#inlinable_f_incr_counter"><span class="id" title="definition">inlinable_f_incr_counter</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <a name="Mdecr"><span class="id" title="definition">Mdecr</span></a> : <a class="idref" href="liblayers.compcertx.ClightModules.html#cmodule"><span class="id" title="abbreviation">cmodule</span></a> := <a class="idref" href="tutorial.stack.Counter.html#decr_counter"><span class="id" title="definition">decr_counter</span></a> <a class="idref" href="liblayers.logic.Structures.html#33228780c4c171a6131f9e6e62ea2dd4"><span class="id" title="notation">↦</span></a> <a class="idref" href="tutorial.stack.Counter.html#inlinable_f_decr_counter"><span class="id" title="definition">inlinable_f_decr_counter</span></a>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">End</span> <a class="idref" href="tutorial.stack.Counter.html#Counter.Code"><span class="id" title="section">Code</span></a>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab696"></a><h2 class="section">Low Level Specifications</h2>

</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="keyword">Section</span> <a name="Counter.LowSpec"><span class="id" title="section">LowSpec</span></a>.<br/>
</div>

<div class="doc">
Next we define a low-level specification of each primitive, i.e. a
      specification with respect to the underlay. We define those as transition
      relations <span class="inlinecode"><a class="idref" href="compcert.backend.CminorSel.html#step"><span class="id" title="inductive">step</span></a></span> of type <span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#list"><span class="id" title="inductive">list</span></a></span> <span class="inlinecode"><a class="idref" href="compcert.common.Values.html#val"><span class="id" title="inductive">val</span></a></span> <span class="inlinecode">→</span> <span class="inlinecode"><a class="idref" href="liblayers.simrel.MemWithData.html#mem"><span class="id" title="projection">mem</span></a></span> <span class="inlinecode">→</span> <span class="inlinecode"><a class="idref" href="compcert.common.Values.html#val"><span class="id" title="inductive">val</span></a></span> <span class="inlinecode">→</span> <span class="inlinecode"><a class="idref" href="liblayers.simrel.MemWithData.html#mem"><span class="id" title="projection">mem</span></a></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>. The
      meaning of <span class="inlinecode"><a class="idref" href="compcert.backend.CminorSel.html#step"><span class="id" title="inductive">step</span></a></span> <span class="inlinecode"><a class="idref" href="compcert.common.Events.html#args"><span class="id" title="variable">args</span></a></span> <span class="inlinecode">(<a class="idref" href="compcert.x86.SelectLongproof.html#CMCONSTR.m"><span class="id" title="variable">m</span></a>,</span> <span class="inlinecode"><a class="idref" href="compcert.flocq.Appli.Fappli_rnd_odd.html#Odd_prop_aux.d"><span class="id" title="variable">d</span></a>)</span> <span class="inlinecode"><a class="idref" href="compcert.common.Errors.html#res"><span class="id" title="inductive">res</span></a></span> <span class="inlinecode">(<a class="idref" href="compcert.cfrontend.Cop.html#WITHMEMORYMODEL.GENERIC_INJECTION.m'"><span class="id" title="variable">m'</span></a>,</span> <span class="inlinecode"><a class="idref" href="liblayers.compcertx.GenSem.html#d'"><span class="id" title="variable">d'</span></a>)</span> is the following:
      given arguments <span class="inlinecode"><a class="idref" href="compcert.common.Events.html#args"><span class="id" title="variable">args</span></a></span> and starting from a memory state <span class="inlinecode"><a class="idref" href="compcert.x86.SelectLongproof.html#CMCONSTR.m"><span class="id" title="variable">m</span></a></span> with
      abstract data <span class="inlinecode"><a class="idref" href="compcert.flocq.Appli.Fappli_rnd_odd.html#Odd_prop_aux.d"><span class="id" title="variable">d</span></a></span>, the primitive returns a value <span class="inlinecode"><a class="idref" href="compcert.common.Errors.html#res"><span class="id" title="inductive">res</span></a></span>, the memory state
      is updated to <span class="inlinecode"><a class="idref" href="compcert.cfrontend.Cop.html#WITHMEMORYMODEL.GENERIC_INJECTION.m'"><span class="id" title="variable">m'</span></a></span> and the abstract data is now <span class="inlinecode"><a class="idref" href="liblayers.compcertx.GenSem.html#d'"><span class="id" title="variable">d'</span></a></span>. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <a name="get_counter_csig"><span class="id" title="definition">get_counter_csig</span></a> := <a class="idref" href="liblayers.compcertx.CompcertStructures.html#mkcsig"><span class="id" title="definition">mkcsig</span></a> <a class="idref" href="compcert.cfrontend.Ctypes.html#Tnil"><span class="id" title="constructor">Ctypes.Tnil</span></a> <a class="idref" href="tutorial.common.TutoLib.html#tuint"><span class="id" title="abbreviation">tuint</span></a>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Inductive</span> <a name="get_counter_step"><span class="id" title="inductive">get_counter_step</span></a> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="liblayers.compcertx.CompcertStructures.html#csignature"><span class="id" title="record">csignature</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#list"><span class="id" title="inductive">list</span></a> <a class="idref" href="compcert.common.Values.html#val"><span class="id" title="inductive">val</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">×</span></a> <a class="idref" href="liblayers.simrel.MemWithData.html#mwd"><span class="id" title="definition">mwd</span></a> <a class="idref" href="tutorial.stack.Counter.html#base_layerdata"><span class="id" title="definition">base_layerdata</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="compcert.common.Values.html#val"><span class="id" title="inductive">val</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">×</span></a> <a class="idref" href="liblayers.simrel.MemWithData.html#mwd"><span class="id" title="definition">mwd</span></a> <a class="idref" href="tutorial.stack.Counter.html#base_layerdata"><span class="id" title="definition">base_layerdata</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a name="get_counter_step_intro"><span class="id" title="constructor">get_counter_step_intro</span></a> <span class="id" title="var">m</span> <span class="id" title="var">d</span> <span class="id" title="var">cb</span> <span class="id" title="var">i</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div>

<div class="doc">
The <span class="inlinecode"><a class="idref" href="tutorial.stack.Counter.html#COUNTER"><span class="id" title="definition">COUNTER</span></a></span> global variable is stored at some memory block <span class="inlinecode"><a class="idref" href="tutorial.stack.Stack.html#sb"><span class="id" title="variable">sb</span></a></span> 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">∀</span> (<span class="id" title="var">HCb</span>: <a class="idref" href="liblayers.compcertx.CompcertStructures.html#find_symbol"><span class="id" title="definition">find_symbol</span></a> <a class="idref" href="tutorial.stack.Counter.html#COUNTER"><span class="id" title="definition">COUNTER</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#Some"><span class="id" title="constructor">Some</span></a> <a class="idref" href="tutorial.stack.Counter.html#cb"><span class="id" title="variable">cb</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div>

<div class="doc">
The value at block <span class="inlinecode"><a class="idref" href="tutorial.stack.Counter.html#cb"><span class="id" title="variable">cb</span></a></span> is an integer <span class="inlinecode"><a class="idref" href="compcert.lib.Coqlib.html#i"><span class="id" title="variable">i</span></a></span> 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="compcert.common.Memtype.html#Mem.load"><span class="id" title="method">Mem.load</span></a> <a class="idref" href="compcert.common.AST.html#Mint32"><span class="id" title="constructor">Mint32</span></a> <a class="idref" href="tutorial.stack.Counter.html#m"><span class="id" title="variable">m</span></a> <a class="idref" href="tutorial.stack.Counter.html#cb"><span class="id" title="variable">cb</span></a> 0 <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#Some"><span class="id" title="constructor">Some</span></a> (<a class="idref" href="compcert.common.Values.html#Vint"><span class="id" title="constructor">Vint</span></a> <a class="idref" href="tutorial.stack.Counter.html#i"><span class="id" title="variable">i</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div>

<div class="doc">
<span class="inlinecode"><a class="idref" href="tutorial.stack.Counter.html#get_counter"><span class="id" title="definition">get_counter</span></a></span> takes no arguments, returns <span class="inlinecode"><a class="idref" href="compcert.lib.Coqlib.html#i"><span class="id" title="variable">i</span></a></span>, and makes no changes
          to abstract state or memory 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="tutorial.stack.Counter.html#get_counter_step"><span class="id" title="inductive">get_counter_step</span></a> <a class="idref" href="tutorial.stack.Counter.html#get_counter_csig"><span class="id" title="definition">get_counter_csig</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">(</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nil"><span class="id" title="constructor">nil</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">,</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">(</span></a><a class="idref" href="tutorial.stack.Counter.html#m"><span class="id" title="variable">m</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">,</span></a> <a class="idref" href="tutorial.stack.Counter.html#d"><span class="id" title="variable">d</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">))</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">(</span></a><a class="idref" href="compcert.common.Values.html#Vint"><span class="id" title="constructor">Vint</span></a> <a class="idref" href="tutorial.stack.Counter.html#i"><span class="id" title="variable">i</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">,</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">(</span></a><a class="idref" href="tutorial.stack.Counter.html#m"><span class="id" title="variable">m</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">,</span></a> <a class="idref" href="tutorial.stack.Counter.html#d"><span class="id" title="variable">d</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">))</span></a>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <a name="incr_counter_csig"><span class="id" title="definition">incr_counter_csig</span></a> := <a class="idref" href="liblayers.compcertx.CompcertStructures.html#mkcsig"><span class="id" title="definition">mkcsig</span></a> <a class="idref" href="compcert.cfrontend.Ctypes.html#Tnil"><span class="id" title="constructor">Ctypes.Tnil</span></a> <a class="idref" href="tutorial.common.TutoLib.html#tuint"><span class="id" title="abbreviation">tuint</span></a>.<br/>

<br/>
</div>

<div class="doc">
TUTORIAL: Replace the four Falses in this inductive definition with appropriate hypotheses 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Inductive</span> <a name="incr_counter_step"><span class="id" title="inductive">incr_counter_step</span></a> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="liblayers.compcertx.CompcertStructures.html#csignature"><span class="id" title="record">csignature</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#list"><span class="id" title="inductive">list</span></a> <a class="idref" href="compcert.common.Values.html#val"><span class="id" title="inductive">val</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">×</span></a> <a class="idref" href="liblayers.simrel.MemWithData.html#mwd"><span class="id" title="definition">mwd</span></a> <a class="idref" href="tutorial.stack.Counter.html#base_layerdata"><span class="id" title="definition">base_layerdata</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="compcert.common.Values.html#val"><span class="id" title="inductive">val</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">×</span></a> <a class="idref" href="liblayers.simrel.MemWithData.html#mwd"><span class="id" title="definition">mwd</span></a> <a class="idref" href="tutorial.stack.Counter.html#base_layerdata"><span class="id" title="definition">base_layerdata</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a name="incr_counter_step_intro"><span class="id" title="constructor">incr_counter_step_intro</span></a> <span class="id" title="var">m</span> <span class="id" title="var">d</span> <span class="id" title="var">cb</span> (<span class="id" title="var">i</span> : <a class="idref" href="compcert.lib.Integers.html#int"><span class="id" title="abbreviation">int</span></a>) <span class="id" title="var">j</span> <span class="id" title="var">m'</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div>

<div class="doc">
The <span class="inlinecode"><a class="idref" href="tutorial.stack.Counter.html#COUNTER"><span class="id" title="definition">COUNTER</span></a></span> global variable is stored at some memory block <span class="inlinecode"><a class="idref" href="tutorial.stack.Counter.html#cb"><span class="id" title="variable">cb</span></a></span> 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">∀</span> (<span class="id" title="var">HCb</span>: <a class="idref" href="liblayers.compcertx.CompcertStructures.html#find_symbol"><span class="id" title="definition">find_symbol</span></a> <a class="idref" href="tutorial.stack.Counter.html#COUNTER"><span class="id" title="definition">COUNTER</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#Some"><span class="id" title="constructor">Some</span></a> <a class="idref" href="tutorial.stack.Counter.html#cb"><span class="id" title="variable">cb</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div>

<div class="doc">
The value at block <span class="inlinecode"><a class="idref" href="tutorial.stack.Counter.html#cb"><span class="id" title="variable">cb</span></a></span> is an integer <span class="inlinecode"><a class="idref" href="compcert.lib.Coqlib.html#i"><span class="id" title="variable">i</span></a></span> 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#False"><span class="id" title="inductive">False</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div>

<div class="doc">
<span class="inlinecode"><a class="idref" href="compcert.lib.Coqlib.html#i"><span class="id" title="variable">i</span></a></span> is less than <span class="inlinecode"><a class="idref" href="tutorial.stack.Counter.html#MAX_COUNTER"><span class="id" title="definition">MAX_COUNTER</span></a></span> 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#False"><span class="id" title="inductive">False</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div>

<div class="doc">
A new integer <span class="inlinecode"><a class="idref" href="compcert.lib.Maps.html#j"><span class="id" title="variable">j</span></a></span> is defined as <span class="inlinecode"><a class="idref" href="compcert.lib.Coqlib.html#i"><span class="id" title="variable">i</span></a></span> <span class="inlinecode">+</span> <span class="inlinecode">1</span> 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#False"><span class="id" title="inductive">False</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div>

<div class="doc">
Storing <span class="inlinecode"><a class="idref" href="compcert.lib.Maps.html#j"><span class="id" title="variable">j</span></a></span> at block <span class="inlinecode"><a class="idref" href="tutorial.stack.Counter.html#cb"><span class="id" title="variable">cb</span></a></span> results in a new memory <span class="inlinecode"><a class="idref" href="compcert.cfrontend.Cop.html#WITHMEMORYMODEL.GENERIC_INJECTION.m'"><span class="id" title="variable">m'</span></a></span> 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#False"><span class="id" title="inductive">False</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div>

<div class="doc">
<span class="inlinecode"><a class="idref" href="tutorial.stack.Counter.html#incr_counter"><span class="id" title="definition">incr_counter</span></a></span> takes no arguments, returns <span class="inlinecode"><a class="idref" href="compcert.lib.Maps.html#j"><span class="id" title="variable">j</span></a></span>, changes <span class="inlinecode"><a class="idref" href="compcert.x86.SelectLongproof.html#CMCONSTR.m"><span class="id" title="variable">m</span></a></span> to
          <span class="inlinecode"><a class="idref" href="compcert.cfrontend.Cop.html#WITHMEMORYMODEL.GENERIC_INJECTION.m'"><span class="id" title="variable">m'</span></a></span>, and makes no change to abstract state 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="tutorial.stack.Counter.html#incr_counter_step"><span class="id" title="inductive">incr_counter_step</span></a> <a class="idref" href="tutorial.stack.Counter.html#incr_counter_csig"><span class="id" title="definition">incr_counter_csig</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">(</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nil"><span class="id" title="constructor">nil</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">,</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">(</span></a><a class="idref" href="tutorial.stack.Counter.html#m"><span class="id" title="variable">m</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">,</span></a> <a class="idref" href="tutorial.stack.Counter.html#d"><span class="id" title="variable">d</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">))</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">(</span></a><a class="idref" href="compcert.common.Values.html#Vint"><span class="id" title="constructor">Vint</span></a> <a class="idref" href="tutorial.stack.Counter.html#j"><span class="id" title="variable">j</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">,</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">(</span></a><a class="idref" href="tutorial.stack.Counter.html#m'"><span class="id" title="variable">m'</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">,</span></a> <a class="idref" href="tutorial.stack.Counter.html#d"><span class="id" title="variable">d</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">))</span></a>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <a name="decr_counter_csig"><span class="id" title="definition">decr_counter_csig</span></a> := <a class="idref" href="liblayers.compcertx.CompcertStructures.html#mkcsig"><span class="id" title="definition">mkcsig</span></a> <a class="idref" href="compcert.cfrontend.Ctypes.html#Tnil"><span class="id" title="constructor">Ctypes.Tnil</span></a> <a class="idref" href="tutorial.common.TutoLib.html#tuint"><span class="id" title="abbreviation">tuint</span></a>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Inductive</span> <a name="decr_counter_step"><span class="id" title="inductive">decr_counter_step</span></a> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="liblayers.compcertx.CompcertStructures.html#csignature"><span class="id" title="record">csignature</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#list"><span class="id" title="inductive">list</span></a> <a class="idref" href="compcert.common.Values.html#val"><span class="id" title="inductive">val</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">×</span></a> <a class="idref" href="liblayers.simrel.MemWithData.html#mwd"><span class="id" title="definition">mwd</span></a> <a class="idref" href="tutorial.stack.Counter.html#base_layerdata"><span class="id" title="definition">base_layerdata</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="compcert.common.Values.html#val"><span class="id" title="inductive">val</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">×</span></a> <a class="idref" href="liblayers.simrel.MemWithData.html#mwd"><span class="id" title="definition">mwd</span></a> <a class="idref" href="tutorial.stack.Counter.html#base_layerdata"><span class="id" title="definition">base_layerdata</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a name="decr_counter_step_intro"><span class="id" title="constructor">decr_counter_step_intro</span></a> <span class="id" title="var">m</span> <span class="id" title="var">d</span> <span class="id" title="var">cb</span> <span class="id" title="var">i</span> <span class="id" title="var">j</span> <span class="id" title="var">m'</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div>

<div class="doc">
The <span class="inlinecode"><a class="idref" href="tutorial.stack.Counter.html#COUNTER"><span class="id" title="definition">COUNTER</span></a></span> global variable is stored at some memory block <span class="inlinecode"><a class="idref" href="tutorial.stack.Counter.html#cb"><span class="id" title="variable">cb</span></a></span> 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">∀</span> (<span class="id" title="var">HCb</span>: <a class="idref" href="liblayers.compcertx.CompcertStructures.html#find_symbol"><span class="id" title="definition">find_symbol</span></a> <a class="idref" href="tutorial.stack.Counter.html#COUNTER"><span class="id" title="definition">COUNTER</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#Some"><span class="id" title="constructor">Some</span></a> <a class="idref" href="tutorial.stack.Counter.html#cb"><span class="id" title="variable">cb</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div>

<div class="doc">
The value at block <span class="inlinecode"><a class="idref" href="tutorial.stack.Counter.html#cb"><span class="id" title="variable">cb</span></a></span> is an integer <span class="inlinecode"><a class="idref" href="compcert.lib.Coqlib.html#i"><span class="id" title="variable">i</span></a></span> 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="compcert.common.Memtype.html#Mem.load"><span class="id" title="method">Mem.load</span></a> <a class="idref" href="compcert.common.AST.html#Mint32"><span class="id" title="constructor">Mint32</span></a> <a class="idref" href="tutorial.stack.Counter.html#m"><span class="id" title="variable">m</span></a> <a class="idref" href="tutorial.stack.Counter.html#cb"><span class="id" title="variable">cb</span></a> 0 <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#Some"><span class="id" title="constructor">Some</span></a> (<a class="idref" href="compcert.common.Values.html#Vint"><span class="id" title="constructor">Vint</span></a> <a class="idref" href="tutorial.stack.Counter.html#i"><span class="id" title="variable">i</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div>

<div class="doc">
<span class="inlinecode"><a class="idref" href="compcert.lib.Coqlib.html#i"><span class="id" title="variable">i</span></a></span> is greater than <span class="inlinecode">0</span> 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0 <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.ZArith.BinInt.html#273beba4f3453dbb29192b3ac740bb71"><span class="id" title="notation">&lt;</span></a> <a class="idref" href="compcert.lib.Integers.html#Int.unsigned"><span class="id" title="definition">Int.unsigned</span></a> <a class="idref" href="tutorial.stack.Counter.html#i"><span class="id" title="variable">i</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div>

<div class="doc">
A new integer <span class="inlinecode"><a class="idref" href="compcert.lib.Maps.html#j"><span class="id" title="variable">j</span></a></span> is defined as <span class="inlinecode"><a class="idref" href="compcert.lib.Coqlib.html#i"><span class="id" title="variable">i</span></a></span> <span class="inlinecode">-</span> <span class="inlinecode">1</span> 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="tutorial.stack.Counter.html#j"><span class="id" title="variable">j</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="compcert.lib.Integers.html#Int.sub"><span class="id" title="definition">Int.sub</span></a> <a class="idref" href="tutorial.stack.Counter.html#i"><span class="id" title="variable">i</span></a> <a class="idref" href="compcert.lib.Integers.html#Int.one"><span class="id" title="definition">Int.one</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div>

<div class="doc">
Storing <span class="inlinecode"><a class="idref" href="compcert.lib.Maps.html#j"><span class="id" title="variable">j</span></a></span> at block <span class="inlinecode"><a class="idref" href="tutorial.stack.Counter.html#cb"><span class="id" title="variable">cb</span></a></span> results in a new memory <span class="inlinecode"><a class="idref" href="compcert.cfrontend.Cop.html#WITHMEMORYMODEL.GENERIC_INJECTION.m'"><span class="id" title="variable">m'</span></a></span> 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="compcert.common.Memtype.html#Mem.store"><span class="id" title="method">Mem.store</span></a> <a class="idref" href="compcert.common.AST.html#Mint32"><span class="id" title="constructor">Mint32</span></a> <a class="idref" href="tutorial.stack.Counter.html#m"><span class="id" title="variable">m</span></a> <a class="idref" href="tutorial.stack.Counter.html#cb"><span class="id" title="variable">cb</span></a> 0 (<a class="idref" href="compcert.common.Values.html#Vint"><span class="id" title="constructor">Vint</span></a> <a class="idref" href="tutorial.stack.Counter.html#j"><span class="id" title="variable">j</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#Some"><span class="id" title="constructor">Some</span></a> <a class="idref" href="tutorial.stack.Counter.html#m'"><span class="id" title="variable">m'</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div>

<div class="doc">
<span class="inlinecode"><a class="idref" href="tutorial.stack.Counter.html#decr_counter"><span class="id" title="definition">decr_counter</span></a></span> takes no arguments, returns <span class="inlinecode"><a class="idref" href="compcert.lib.Maps.html#j"><span class="id" title="variable">j</span></a></span>, changes <span class="inlinecode"><a class="idref" href="compcert.x86.SelectLongproof.html#CMCONSTR.m"><span class="id" title="variable">m</span></a></span> to
          <span class="inlinecode"><a class="idref" href="compcert.cfrontend.Cop.html#WITHMEMORYMODEL.GENERIC_INJECTION.m'"><span class="id" title="variable">m'</span></a></span>, and makes no change to abstract state 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="tutorial.stack.Counter.html#decr_counter_step"><span class="id" title="inductive">decr_counter_step</span></a> <a class="idref" href="tutorial.stack.Counter.html#decr_counter_csig"><span class="id" title="definition">decr_counter_csig</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">(</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nil"><span class="id" title="constructor">nil</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">,</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">(</span></a><a class="idref" href="tutorial.stack.Counter.html#m"><span class="id" title="variable">m</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">,</span></a> <a class="idref" href="tutorial.stack.Counter.html#d"><span class="id" title="variable">d</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">))</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">(</span></a><a class="idref" href="compcert.common.Values.html#Vint"><span class="id" title="constructor">Vint</span></a> <a class="idref" href="tutorial.stack.Counter.html#j"><span class="id" title="variable">j</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">,</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">(</span></a><a class="idref" href="tutorial.stack.Counter.html#m'"><span class="id" title="variable">m'</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">,</span></a> <a class="idref" href="tutorial.stack.Counter.html#d"><span class="id" title="variable">d</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">))</span></a>.<br/>

<br/>
</div>

<div class="doc">
As with the high-level specifications, to use the low-level specs in a
      layer definition, we must wrap it in a <span class="inlinecode"><a class="idref" href="liblayers.compcertx.CPrimitives.html#cprimitive"><span class="id" title="record">cprimitive</span></a></span> using the
      <span class="inlinecode"><a class="idref" href="liblayers.compcertx.CPrimitives.html#mkcprimitive"><span class="id" title="definition">mkcprimitive</span></a></span> function. This generates a proof obligation that says the
      return value has the appropriate type. Since this obligation is fairly
      trivial we use a custom tactic to discharge it for all but the first
      primitive. 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <a name="get_counter_cprimitive"><span class="id" title="definition">get_counter_cprimitive</span></a> : <a class="idref" href="liblayers.compcertx.CPrimitives.html#cprimitive"><span class="id" title="record">cprimitive</span></a> <a class="idref" href="tutorial.stack.Counter.html#base_layerdata"><span class="id" title="definition">base_layerdata</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (<a class="idref" href="liblayers.compcertx.CPrimitives.html#mkcprimitive"><span class="id" title="definition">mkcprimitive</span></a> <span class="id" title="var">_</span> <a class="idref" href="tutorial.stack.Counter.html#get_counter_step"><span class="id" title="inductive">get_counter_step</span></a> <a class="idref" href="tutorial.stack.Counter.html#get_counter_csig"><span class="id" title="definition">get_counter_csig</span></a> <span class="id" title="var">_</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> ? ? ? ? <span class="id" title="var">Hstep</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">inv</span> <span class="id" title="var">Hstep</span>. <span class="id" title="var">cbn</span>. <span class="id" title="tactic">trivial</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Defined</span>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <a name="incr_counter_cprimitive"><span class="id" title="definition">incr_counter_cprimitive</span></a> : <a class="idref" href="liblayers.compcertx.CPrimitives.html#cprimitive"><span class="id" title="record">cprimitive</span></a> <a class="idref" href="tutorial.stack.Counter.html#base_layerdata"><span class="id" title="definition">base_layerdata</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>. <span class="id" title="var">mkcprim_tac</span> <a class="idref" href="tutorial.stack.Counter.html#incr_counter_step"><span class="id" title="inductive">incr_counter_step</span></a> <a class="idref" href="tutorial.stack.Counter.html#incr_counter_csig"><span class="id" title="definition">incr_counter_csig</span></a>. <span class="id" title="keyword">Defined</span>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <a name="decr_counter_cprimitive"><span class="id" title="definition">decr_counter_cprimitive</span></a> : <a class="idref" href="liblayers.compcertx.CPrimitives.html#cprimitive"><span class="id" title="record">cprimitive</span></a> <a class="idref" href="tutorial.stack.Counter.html#base_layerdata"><span class="id" title="definition">base_layerdata</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>. <span class="id" title="var">mkcprim_tac</span> <a class="idref" href="tutorial.stack.Counter.html#decr_counter_step"><span class="id" title="inductive">decr_counter_step</span></a> <a class="idref" href="tutorial.stack.Counter.html#decr_counter_csig"><span class="id" title="definition">decr_counter_csig</span></a>. <span class="id" title="keyword">Defined</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">End</span> <a class="idref" href="tutorial.stack.Counter.html#Counter.LowSpec"><span class="id" title="section">LowSpec</span></a>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab697"></a><h2 class="section">Code Proofs</h2>

</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="keyword">Section</span> <a name="Counter.CodeLowSpecSim"><span class="id" title="section">CodeLowSpecSim</span></a>.<br/>
</div>

<div class="doc">
Now we want to show that these implementations are correct with respect
      to the underlay and overlay. We will do that in two steps for each
      primitive. First, we prove that the module implementation together with
      the underlay refines the low-level specification. Later, we will prove
      that the low-level specification refines the high-level specification. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Context</span> `{<span class="id" title="var">ce</span>: <a class="idref" href="liblayers.compcertx.ClightXSemantics.html#ClightCompositeEnv"><span class="id" title="class">ClightCompositeEnv</span></a>}.<br/>

<br/>
</div>

<div class="doc">
We state our theorems in the form <span class="inlinecode"><span class="id" title="var">underlay</span></span> <span class="inlinecode">⊢</span> <span class="inlinecode">(<a class="idref" href="compcert.backend.Locations.html#R"><span class="id" title="constructor">R</span></a>,</span> <span class="inlinecode"><a class="idref" href="liblayers.logic.Modules.html#module"><span class="id" title="variable">module</span></a>)</span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">overlay</span></span>
      which says that the code in the module executed on the underlay refines
      the overlay with respect to some relation R. What we actually want to
      prove, however, is a simulation diagram like the following:

<div class="paragraph"> </div>

      (hargs, hstate)    high_spec_step   (hresult, hstate')
          ||            ---------------&gt;        ||
      R   ||                                    ||  R
          ||                                    ||
          \/            ---------------&gt;        \/
      (largs, lstate)    low_spec_step     (lresult, lstate')

<div class="paragraph"> </div>

      In the code proofs, the overlay is the low level spec of some C
      primitive, and R is typically <span class="inlinecode"><a class="idref" href="liblayers.logic.Structures.html#id"><span class="id" title="projection">id</span></a></span>. In this case we can simplify the
      diagram into:

<div class="paragraph"> </div>

                      high_spec_step
      (args, state)  ---------------&gt; (result, state')
                      low_spec_step

<div class="paragraph"> </div>

      The tactic <span class="inlinecode"><span class="id" title="var">code_proof_tac</span></span> will automatically convert the goal into
      the appropriate simulation diagram. You will then have to prove that the
      <span class="inlinecode"><a class="idref" href="liblayers.compcertx.CPrimitives.html#cprimitive_step"><span class="id" title="projection">cprimitive_step</span></a></span> relation holds between the initial and final states.
      <span class="inlinecode"><span class="id" title="var">cprim_step</span></span> will convert this goal into one that states that the final
      state is reachable in a sequence of Clight steps. The <span class="inlinecode"><span class="id" title="var">step_tac</span></span> tactic
      will try to prove all of the Clight smallstep semantics details and just
      leave you with a few remaining goals. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Lemma</span> <a name="get_counter_code"><span class="id" title="lemma">get_counter_code</span></a> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="tutorial.stack.Counter.html#base_L"><span class="id" title="definition">base_L</span></a> <a class="idref" href="liblayers.logic.Structures.html#02b32b237357d2b6b54537b4da97c51a"><span class="id" title="notation">⊢</span></a> <a class="idref" href="liblayers.logic.Structures.html#02b32b237357d2b6b54537b4da97c51a"><span class="id" title="notation">(</span></a><a class="idref" href="liblayers.logic.Structures.html#id"><span class="id" title="method">id</span></a><a class="idref" href="liblayers.logic.Structures.html#02b32b237357d2b6b54537b4da97c51a"><span class="id" title="notation">,</span></a> <a class="idref" href="tutorial.stack.Counter.html#Mget"><span class="id" title="definition">Mget</span></a><a class="idref" href="liblayers.logic.Structures.html#02b32b237357d2b6b54537b4da97c51a"><span class="id" title="notation">)</span></a> <a class="idref" href="liblayers.logic.Structures.html#02b32b237357d2b6b54537b4da97c51a"><span class="id" title="notation">:</span></a> <a class="idref" href="liblayers.logic.Structures.html#02b32b237357d2b6b54537b4da97c51a"><span class="id" title="notation">(</span></a><a class="idref" href="tutorial.stack.Counter.html#get_counter"><span class="id" title="definition">get_counter</span></a> <a class="idref" href="liblayers.logic.Structures.html#33228780c4c171a6131f9e6e62ea2dd4"><span class="id" title="notation">↦</span></a> <a class="idref" href="tutorial.stack.Counter.html#get_counter_cprimitive"><span class="id" title="definition">get_counter_cprimitive</span></a><a class="idref" href="liblayers.logic.Structures.html#02b32b237357d2b6b54537b4da97c51a"><span class="id" title="notation">)</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">code_proof_tac</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">inv</span> <span class="id" title="var">CStep</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">cprim_step</span>. <span class="id" title="tactic">repeat</span> <span class="id" title="var">step_tac</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Qed</span>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Lemma</span> <a name="incr_counter_code"><span class="id" title="lemma">incr_counter_code</span></a> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="tutorial.stack.Counter.html#base_L"><span class="id" title="definition">base_L</span></a> <a class="idref" href="liblayers.logic.Structures.html#02b32b237357d2b6b54537b4da97c51a"><span class="id" title="notation">⊢</span></a> <a class="idref" href="liblayers.logic.Structures.html#02b32b237357d2b6b54537b4da97c51a"><span class="id" title="notation">(</span></a><a class="idref" href="liblayers.logic.Structures.html#id"><span class="id" title="method">id</span></a><a class="idref" href="liblayers.logic.Structures.html#02b32b237357d2b6b54537b4da97c51a"><span class="id" title="notation">,</span></a> <a class="idref" href="tutorial.stack.Counter.html#Mincr"><span class="id" title="definition">Mincr</span></a><a class="idref" href="liblayers.logic.Structures.html#02b32b237357d2b6b54537b4da97c51a"><span class="id" title="notation">)</span></a> <a class="idref" href="liblayers.logic.Structures.html#02b32b237357d2b6b54537b4da97c51a"><span class="id" title="notation">:</span></a> <a class="idref" href="liblayers.logic.Structures.html#02b32b237357d2b6b54537b4da97c51a"><span class="id" title="notation">(</span></a><a class="idref" href="tutorial.stack.Counter.html#incr_counter"><span class="id" title="definition">incr_counter</span></a> <a class="idref" href="liblayers.logic.Structures.html#33228780c4c171a6131f9e6e62ea2dd4"><span class="id" title="notation">↦</span></a> <a class="idref" href="tutorial.stack.Counter.html#incr_counter_cprimitive"><span class="id" title="definition">incr_counter_cprimitive</span></a><a class="idref" href="liblayers.logic.Structures.html#02b32b237357d2b6b54537b4da97c51a"><span class="id" title="notation">)</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">code_proof_tac</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">inv</span> <span class="id" title="var">CStep</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">contradiction</span>.<br/>
</div>

<div class="doc">
TUTORIAL: Replace invalid contradiction with an actual proof. 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">Admitted</span>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Lemma</span> <a name="decr_counter_code"><span class="id" title="lemma">decr_counter_code</span></a> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="tutorial.stack.Counter.html#base_L"><span class="id" title="definition">base_L</span></a> <a class="idref" href="liblayers.logic.Structures.html#02b32b237357d2b6b54537b4da97c51a"><span class="id" title="notation">⊢</span></a> <a class="idref" href="liblayers.logic.Structures.html#02b32b237357d2b6b54537b4da97c51a"><span class="id" title="notation">(</span></a><a class="idref" href="liblayers.logic.Structures.html#id"><span class="id" title="method">id</span></a><a class="idref" href="liblayers.logic.Structures.html#02b32b237357d2b6b54537b4da97c51a"><span class="id" title="notation">,</span></a> <a class="idref" href="tutorial.stack.Counter.html#Mdecr"><span class="id" title="definition">Mdecr</span></a><a class="idref" href="liblayers.logic.Structures.html#02b32b237357d2b6b54537b4da97c51a"><span class="id" title="notation">)</span></a> <a class="idref" href="liblayers.logic.Structures.html#02b32b237357d2b6b54537b4da97c51a"><span class="id" title="notation">:</span></a> <a class="idref" href="liblayers.logic.Structures.html#02b32b237357d2b6b54537b4da97c51a"><span class="id" title="notation">(</span></a><a class="idref" href="tutorial.stack.Counter.html#decr_counter"><span class="id" title="definition">decr_counter</span></a> <a class="idref" href="liblayers.logic.Structures.html#33228780c4c171a6131f9e6e62ea2dd4"><span class="id" title="notation">↦</span></a> <a class="idref" href="tutorial.stack.Counter.html#decr_counter_cprimitive"><span class="id" title="definition">decr_counter_cprimitive</span></a><a class="idref" href="liblayers.logic.Structures.html#02b32b237357d2b6b54537b4da97c51a"><span class="id" title="notation">)</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">code_proof_tac</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">inv</span> <span class="id" title="var">CStep</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">cprim_step</span>. <span class="id" title="tactic">repeat</span> <span class="id" title="var">step_tac</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" title="var">cbn</span>. <span class="id" title="tactic">change</span> (<a class="idref" href="compcert.lib.Integers.html#Int.repr"><span class="id" title="definition">Int.repr</span></a> 0) <span class="id" title="keyword">with</span> <a class="idref" href="compcert.lib.Integers.html#Int.zero"><span class="id" title="definition">Int.zero</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">instantiate</span> (1 := <a class="idref" href="compcert.lib.Integers.html#Int.ltu"><span class="id" title="definition">Int.ltu</span></a> <a class="idref" href="compcert.lib.Integers.html#Int.zero"><span class="id" title="definition">Int.zero</span></a> <span class="id" title="var">i</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> (<a class="idref" href="compcert.lib.Integers.html#Int.ltu"><span class="id" title="definition">Int.ltu</span></a> <a class="idref" href="compcert.lib.Integers.html#Int.zero"><span class="id" title="definition">Int.zero</span></a> <span class="id" title="var">i</span>); <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" title="var">destr</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ </div>

<div class="doc">
0 &lt; i 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">repeat</span> <span class="id" title="var">step_tac</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;× </div>

<div class="doc">
Storing i - 1 gives m' 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <a class="idref" href="liblayers.lib.Lift.html#lift"><span class="id" title="method">lift</span></a>; <span class="id" title="var">cbn</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <a class="idref" href="compcert.lib.Integers.html#Ptrofs.unsigned_zero"><span class="id" title="lemma">Ptrofs.unsigned_zero</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <a class="idref" href="compcert.lib.Integers.html#Int.one"><span class="id" title="definition">Int.one</span></a> <span class="id" title="keyword">in</span> <span class="id" title="var">H10</span>. <span class="id" title="tactic">rewrite</span> <span class="id" title="var">H10</span>. <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;× </div>

<div class="doc">
Loading m' gives i - 1 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <a class="idref" href="liblayers.lib.Lift.html#lift"><span class="id" title="method">lift</span></a>; <span class="id" title="var">cbn</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <a class="idref" href="compcert.lib.Integers.html#Ptrofs.unsigned_zero"><span class="id" title="lemma">Ptrofs.unsigned_zero</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">eapply</span> <a class="idref" href="compcert.common.Memtype.html#Mem.load_store_same"><span class="id" title="method">Mem.load_store_same</span></a>; <span class="id" title="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;× </div>

<div class="doc">
Return value is i - 1 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ </div>

<div class="doc">
0 &gt;= i 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <a class="idref" href="compcert.lib.Integers.html#Int.ltu"><span class="id" title="definition">Int.ltu</span></a> <span class="id" title="keyword">in</span> <span class="id" title="var">Heqb</span>. <span class="id" title="var">destr_in</span> <span class="id" title="var">Heqb</span>; [<span class="id" title="tactic">discriminate</span> | <span class="id" title="var">contradiction</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Qed</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">End</span> <a class="idref" href="tutorial.stack.Counter.html#Counter.CodeLowSpecSim"><span class="id" title="section">CodeLowSpecSim</span></a>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab698"></a><h2 class="section">Layer Relation</h2>

</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="keyword">Section</span> <a name="Counter.LowHighSpecRel"><span class="id" title="section">LowHighSpecRel</span></a>.<br/>
</div>

<div class="doc">
Finally, we want to match the high-level specifications of our
      primitives to the low-level specifications.

<div class="paragraph"> </div>

      To achieve this, we need to build an abstraction relation (<span class="inlinecode"><a class="idref" href="liblayers.simrel.AbstractionRelation.html#abrel"><span class="id" title="record">abrel</span></a></span>),
      which requires two components:

<div class="paragraph"> </div>

<ul class="doclist">
<li> <span class="inlinecode"><a class="idref" href="tutorial.stack.Counter.html#match_data"><span class="id" title="inductive">match_data</span></a></span>: a matching relation between the abstract data in the
        overlay and the memory state in the underlay

<div class="paragraph"> </div>


</li>
<li> <span class="inlinecode"><a class="idref" href="tutorial.stack.Counter.html#relate_data"><span class="id" title="record">relate_data</span></a></span>: a relation between high and low abstract data 
</li>
</ul>

<div class="paragraph"> </div>

 In our case, the <span class="inlinecode"><a class="idref" href="tutorial.stack.Counter.html#match_data"><span class="id" title="inductive">match_data</span></a></span> predicate states that the memory
      associated with the <span class="inlinecode"><a class="idref" href="tutorial.stack.Counter.html#COUNTER"><span class="id" title="definition">COUNTER</span></a></span> variable must match <span class="inlinecode"><a class="idref" href="tutorial.stack.Counter.html#counter"><span class="id" title="projection">counter</span></a></span> in the high
      abstract data. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Inductive</span> <a name="match_data"><span class="id" title="inductive">match_data</span></a> : <a class="idref" href="tutorial.stack.Counter.html#counter_layerdata"><span class="id" title="definition">counter_layerdata</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="liblayers.simrel.MemWithData.html#mem"><span class="id" title="method">mem</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a name="match_data_intro"><span class="id" title="constructor">match_data_intro</span></a>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">∀</span> <span class="id" title="var">m</span> <span class="id" title="var">b</span> <span class="id" title="var">i</span> (<span class="id" title="var">abs</span>: <a class="idref" href="tutorial.stack.Counter.html#counter_layerdata"><span class="id" title="definition">counter_layerdata</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div>

<div class="doc">
The <span class="inlinecode"><a class="idref" href="tutorial.stack.Counter.html#COUNTER"><span class="id" title="definition">COUNTER</span></a></span> global variable is stored at some memory block <span class="inlinecode"><a class="idref" href="compcert.backend.Bounds.html#WITHIN_BOUNDS.b"><span class="id" title="variable">b</span></a></span> 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="liblayers.compcertx.CompcertStructures.html#find_symbol"><span class="id" title="definition">find_symbol</span></a> <a class="idref" href="tutorial.stack.Counter.html#COUNTER"><span class="id" title="definition">COUNTER</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#Some"><span class="id" title="constructor">Some</span></a> <a class="idref" href="tutorial.stack.Counter.html#b"><span class="id" title="variable">b</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div>

<div class="doc">
The value at block <span class="inlinecode"><a class="idref" href="compcert.backend.Bounds.html#WITHIN_BOUNDS.b"><span class="id" title="variable">b</span></a></span> is an integer <span class="inlinecode"><a class="idref" href="compcert.lib.Coqlib.html#i"><span class="id" title="variable">i</span></a></span> 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="compcert.common.Memtype.html#Mem.load"><span class="id" title="method">Mem.load</span></a> <a class="idref" href="compcert.common.AST.html#Mint32"><span class="id" title="constructor">Mint32</span></a> <a class="idref" href="tutorial.stack.Counter.html#m"><span class="id" title="variable">m</span></a> <a class="idref" href="tutorial.stack.Counter.html#b"><span class="id" title="variable">b</span></a> 0 <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#Some"><span class="id" title="constructor">Some</span></a> (<a class="idref" href="compcert.common.Values.html#Vint"><span class="id" title="constructor">Vint</span></a> <a class="idref" href="tutorial.stack.Counter.html#i"><span class="id" title="variable">i</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div>

<div class="doc">
The value of <span class="inlinecode"><a class="idref" href="tutorial.stack.Counter.html#counter"><span class="id" title="projection">counter</span></a></span> in the abstract data equals <span class="inlinecode"><a class="idref" href="compcert.lib.Coqlib.html#i"><span class="id" title="variable">i</span></a></span> 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="tutorial.stack.Counter.html#counter"><span class="id" title="projection">counter</span></a> <a class="idref" href="tutorial.stack.Counter.html#abs"><span class="id" title="variable">abs</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.ZArith.BinInt.html#Z.to_nat"><span class="id" title="definition">Z.to_nat</span></a> (<a class="idref" href="compcert.lib.Integers.html#Int.unsigned"><span class="id" title="definition">Int.unsigned</span></a> <a class="idref" href="tutorial.stack.Counter.html#i"><span class="id" title="variable">i</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="tutorial.stack.Counter.html#match_data"><span class="id" title="inductive">match_data</span></a> <a class="idref" href="tutorial.stack.Counter.html#abs"><span class="id" title="variable">abs</span></a> <a class="idref" href="tutorial.stack.Counter.html#m"><span class="id" title="variable">m</span></a>.<br/>

<br/>
</div>

<div class="doc">
Since the abstract data of the underlay is just <span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#unit"><span class="id" title="inductive">unit</span></a></span>, <span class="inlinecode"><a class="idref" href="tutorial.stack.Counter.html#relate_data"><span class="id" title="record">relate_data</span></a></span>
      is trivial. 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Record</span> <a name="relate_data"><span class="id" title="record">relate_data</span></a> (<span class="id" title="var">hadt</span>: <a class="idref" href="tutorial.stack.Counter.html#counter_layerdata"><span class="id" title="definition">counter_layerdata</span></a>) (<span class="id" title="var">ladt</span>: <a class="idref" href="tutorial.stack.Counter.html#base_layerdata"><span class="id" title="definition">base_layerdata</span></a>) :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a name="mkrelate_data"><span class="id" title="constructor">mkrelate_data</span></a> {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div>

<div class="doc">
In a more complicated example we might have relations like:

<div class="paragraph"> </div>

          var1 hadt = var1 ladt

<div class="paragraph"> </div>

          or

<div class="paragraph"> </div>

          var1 hadt = var2 ladt + var3 ladt 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}.<br/>

<br/>
</div>

<div class="doc">
We now wrap our relations and a list of the global variables'
      initialization information intro an <span class="inlinecode"><a class="idref" href="liblayers.simrel.AbstractionRelation.html#abrel_components"><span class="id" title="record">abrel_components</span></a></span> record and declare
      it an instance of <span class="inlinecode"><a class="idref" href="liblayers.simrel.AbstractionRelation.html#AbstractionRelation"><span class="id" title="record">AbstractionRelation</span></a></span>. We must now prove the following
      properties:

<div class="paragraph"> </div>

<ul class="doclist">
<li> The <span class="inlinecode"><a class="idref" href="liblayers.simrel.AbstractData.html#init_data"><span class="id" title="projection">init_data</span></a></span> of the high and low abstract data types must be related
        by <span class="inlinecode"><a class="idref" href="liblayers.simrel.AbstractionRelation.html#abrel_relate"><span class="id" title="projection">abrel_relate</span></a></span>.

<div class="paragraph"> </div>


</li>
<li> Given information about the newly-introduced globals, we must show that
        the initial abstract data matches the initial low memory state.

<div class="paragraph"> </div>


</li>
<li> <span class="inlinecode"><a class="idref" href="liblayers.simrel.AbstractionRelation.html#abrel_match"><span class="id" title="projection">abrel_match</span></a></span> should be preserved by <span class="inlinecode"><span class="id" title="var">Mem.unchanged_on</span></span> in the part of
        memory where the global variables are stored. In other words, the match
        relation should only depend on the memory used by the global variables.

</li>
</ul>

<div class="paragraph"> </div>

      <ul class="doclist">
<li> The newly-introduced global variables must have identifiers lower than
        the global threshold. 
</li>
</ul>

</div>
<div class="code">

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <a name="abrel_components_counter_base"><span class="id" title="definition">abrel_components_counter_base</span></a> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="liblayers.simrel.AbstractionRelation.html#abrel_components"><span class="id" title="record">abrel_components</span></a> <a class="idref" href="tutorial.stack.Counter.html#counter_layerdata"><span class="id" title="definition">counter_layerdata</span></a> <a class="idref" href="tutorial.stack.Counter.html#base_layerdata"><span class="id" title="definition">base_layerdata</span></a> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{|<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="liblayers.simrel.AbstractionRelation.html#Build_abrel_components"><span class="id" title="constructor">abrel_relate</span></a> <a class="idref" href="liblayers.simrel.AbstractionRelation.html#Build_abrel_components"><span class="id" title="constructor">:=</span></a> <a class="idref" href="liblayers.simrel.AbstractionRelation.html#Build_abrel_components"><span class="id" title="constructor">relate_data</span></a><a class="idref" href="liblayers.simrel.AbstractionRelation.html#Build_abrel_components"><span class="id" title="constructor">;</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="liblayers.simrel.AbstractionRelation.html#Build_abrel_components"><span class="id" title="constructor">abrel_match</span></a>  <a class="idref" href="liblayers.simrel.AbstractionRelation.html#Build_abrel_components"><span class="id" title="constructor">:=</span></a> <a class="idref" href="liblayers.simrel.AbstractionRelation.html#Build_abrel_components"><span class="id" title="constructor">match_data</span></a><a class="idref" href="liblayers.simrel.AbstractionRelation.html#Build_abrel_components"><span class="id" title="constructor">;</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="liblayers.simrel.AbstractionRelation.html#Build_abrel_components"><span class="id" title="constructor">abrel_new_glbl</span></a> <a class="idref" href="liblayers.simrel.AbstractionRelation.html#Build_abrel_components"><span class="id" title="constructor">:=</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="liblayers.simrel.AbstractionRelation.html#Build_abrel_components"><span class="id" title="constructor">(</span></a><a class="idref" href="liblayers.simrel.AbstractionRelation.html#Build_abrel_components"><span class="id" title="constructor">COUNTER</span></a><a class="idref" href="liblayers.simrel.AbstractionRelation.html#Build_abrel_components"><span class="id" title="constructor">,</span></a> <a class="idref" href="liblayers.simrel.AbstractionRelation.html#Build_abrel_components"><span class="id" title="constructor">AST.Init_int32</span></a> <a class="idref" href="liblayers.simrel.AbstractionRelation.html#Build_abrel_components"><span class="id" title="constructor">Int.zero</span></a> <a class="idref" href="liblayers.simrel.AbstractionRelation.html#Build_abrel_components"><span class="id" title="constructor">::</span></a> <a class="idref" href="liblayers.simrel.AbstractionRelation.html#Build_abrel_components"><span class="id" title="constructor">nil</span></a><a class="idref" href="liblayers.simrel.AbstractionRelation.html#Build_abrel_components"><span class="id" title="constructor">)</span></a> <a class="idref" href="liblayers.simrel.AbstractionRelation.html#Build_abrel_components"><span class="id" title="constructor">::</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="liblayers.simrel.AbstractionRelation.html#Build_abrel_components"><span class="id" title="constructor">nil</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|}.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Global Instance</span> <a name="rel_ops"><span class="id" title="instance">rel_ops</span></a> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="liblayers.simrel.AbstractionRelation.html#AbstractionRelation"><span class="id" title="class">AbstractionRelation</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <a class="idref" href="tutorial.stack.Counter.html#abrel_components_counter_base"><span class="id" title="definition">abrel_components_counter_base</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">constructor</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- </div>

<div class="doc">
Initial abs data matches 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">constructor</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- </div>

<div class="doc">
Initial high abs data matches initial low memory 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">inv_abrel_init_props</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">cbn</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">econstructor</span>; <span class="id" title="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">eapply</span> <span class="id" title="var">aip_load</span>; <span class="id" title="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="var">cbn</span>; <span class="id" title="tactic">rewrite</span> <a class="idref" href="compcert.lib.Integers.html#Int.unsigned_zero"><span class="id" title="lemma">Int.unsigned_zero</span></a>; <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- </div>

<div class="doc">
If global variable memory is unchanged, <span class="inlinecode"><a class="idref" href="liblayers.simrel.AbstractionRelation.html#abrel_match"><span class="id" title="projection">abrel_match</span></a></span> is preserved 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">repeat</span> <span class="id" title="tactic">red</span>; <span class="id" title="var">cbn</span>. <span class="id" title="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">inv</span> <span class="id" title="var">H1</span>; <span class="id" title="tactic">econstructor</span>; <span class="id" title="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">eapply</span> <a class="idref" href="compcert.common.Memtype.html#Mem.load_unchanged_on"><span class="id" title="method">Mem.load_unchanged_on</span></a>; <span class="id" title="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">cbn</span>; <span class="id" title="tactic">intros</span>; <span class="id" title="tactic">red</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">∃</span> <a class="idref" href="tutorial.stack.Counter.html#COUNTER"><span class="id" title="definition">COUNTER</span></a>; <span class="id" title="tactic">eexists</span>. <span class="id" title="var">cbn</span>; <span class="id" title="tactic">split</span>; <span class="id" title="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- </div>

<div class="doc">
Global variable identifiers are lower than <span class="inlinecode"><a class="idref" href="liblayers.compcertx.CompcertStructures.html#glob_threshold"><span class="id" title="definition">glob_threshold</span></a></span> 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">decision</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Finally we wrap everything into an <span class="inlinecode"><a class="idref" href="liblayers.simrel.AbstractionRelation.html#abrel"><span class="id" title="record">abrel</span></a></span> record, which just
      contains the <span class="inlinecode"><a class="idref" href="liblayers.simrel.AbstractionRelation.html#abrel_components"><span class="id" title="record">abrel_components</span></a></span> plus the proof that they are an instance
      of <span class="inlinecode"><a class="idref" href="liblayers.simrel.AbstractionRelation.html#AbstractionRelation"><span class="id" title="record">AbstractionRelation</span></a></span>. 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <a name="abrel_counter_base"><span class="id" title="definition">abrel_counter_base</span></a> : <a class="idref" href="liblayers.simrel.AbstractionRelation.html#abrel"><span class="id" title="record">abrel</span></a> <a class="idref" href="tutorial.stack.Counter.html#counter_layerdata"><span class="id" title="definition">counter_layerdata</span></a> <a class="idref" href="tutorial.stack.Counter.html#base_layerdata"><span class="id" title="definition">base_layerdata</span></a> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{|<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="liblayers.simrel.AbstractionRelation.html#Build_abrel"><span class="id" title="constructor">abrel_ops</span></a> <a class="idref" href="liblayers.simrel.AbstractionRelation.html#Build_abrel"><span class="id" title="constructor">:=</span></a> <a class="idref" href="liblayers.simrel.AbstractionRelation.html#Build_abrel"><span class="id" title="constructor">abrel_components_counter_base</span></a><a class="idref" href="liblayers.simrel.AbstractionRelation.html#Build_abrel"><span class="id" title="constructor">;</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="liblayers.simrel.AbstractionRelation.html#Build_abrel"><span class="id" title="constructor">abrel_prf</span></a> <a class="idref" href="liblayers.simrel.AbstractionRelation.html#Build_abrel"><span class="id" title="constructor">:=</span></a> <a class="idref" href="liblayers.simrel.AbstractionRelation.html#Build_abrel"><span class="id" title="constructor">rel_ops</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|}.<br/>

<br/>
</div>

<div class="doc">
TODO: explain simrel vs abrel? Try to hide it somehow?  It will be convenient to wrap this into a simrel with abrel_simrel. 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <a name="counter_R"><span class="id" title="definition">counter_R</span></a> : <a class="idref" href="liblayers.simrel.SimrelDefinition.html#simrel"><span class="id" title="record">simrel</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> := <a class="idref" href="liblayers.simrel.AbstractionRelation.html#abrel_simrel"><span class="id" title="definition">abrel_simrel</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <a class="idref" href="tutorial.stack.Counter.html#abrel_counter_base"><span class="id" title="definition">abrel_counter_base</span></a>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">End</span> <a class="idref" href="tutorial.stack.Counter.html#Counter.LowHighSpecRel"><span class="id" title="section">LowHighSpecRel</span></a>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab699"></a><h2 class="section">Refinement Proofs</h2>

</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="keyword">Section</span> <a name="Counter.LowHighSpecSim"><span class="id" title="section">LowHighSpecSim</span></a>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Context</span> `{<span class="id" title="var">ce</span>: <a class="idref" href="liblayers.compcertx.ClightXSemantics.html#ClightCompositeEnv"><span class="id" title="class">ClightCompositeEnv</span></a>}.<br/>

<br/>
</div>

<div class="doc">
We can finally prove a simulation between the overlay (with the
      high-level specification of our primitive) and the low-level
      specification of the primitive. In these proofs, the module is empty
      (<span class="inlinecode">∅</span>) because it is purely an abstraction; no additional code is needed.
      The <span class="inlinecode"><span class="id" title="var">refine_proof_tac</span></span> tactic is similar to <span class="inlinecode"><span class="id" title="var">code_proof_tac</span></span> and will
      also convert your goal into a simulation diagram. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Lemma</span> <a name="get_counter_refine"><span class="id" title="lemma">get_counter_refine</span></a> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="liblayers.logic.Structures.html#02b32b237357d2b6b54537b4da97c51a"><span class="id" title="notation">(</span></a><a class="idref" href="tutorial.stack.Counter.html#get_counter"><span class="id" title="definition">get_counter</span></a> <a class="idref" href="liblayers.logic.Structures.html#33228780c4c171a6131f9e6e62ea2dd4"><span class="id" title="notation">↦</span></a> <a class="idref" href="tutorial.stack.Counter.html#get_counter_cprimitive"><span class="id" title="definition">get_counter_cprimitive</span></a><a class="idref" href="liblayers.logic.Structures.html#02b32b237357d2b6b54537b4da97c51a"><span class="id" title="notation">)</span></a> <a class="idref" href="liblayers.logic.Structures.html#02b32b237357d2b6b54537b4da97c51a"><span class="id" title="notation">⊢</span></a> <a class="idref" href="liblayers.logic.Structures.html#02b32b237357d2b6b54537b4da97c51a"><span class="id" title="notation">(</span></a><a class="idref" href="tutorial.stack.Counter.html#counter_R"><span class="id" title="definition">counter_R</span></a><a class="idref" href="liblayers.logic.Structures.html#02b32b237357d2b6b54537b4da97c51a"><span class="id" title="notation">,</span></a> <a class="idref" href="liblayers.logic.Structures.html#1bcfff782645e550303b44d1d50df7a5"><span class="id" title="notation">∅</span></a><a class="idref" href="liblayers.logic.Structures.html#02b32b237357d2b6b54537b4da97c51a"><span class="id" title="notation">)</span></a> <a class="idref" href="liblayers.logic.Structures.html#02b32b237357d2b6b54537b4da97c51a"><span class="id" title="notation">:</span></a> <a class="idref" href="tutorial.stack.Counter.html#get_counter_layer"><span class="id" title="definition">get_counter_layer</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">refine_proof_tac</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">inv</span> <span class="id" title="var">CStep</span>. <span class="id" title="var">inv_generic_sem</span> <span class="id" title="var">H8</span>. <span class="id" title="var">inv_monad</span> <span class="id" title="var">H0</span>. <span class="id" title="var">inv</span> <span class="id" title="var">H0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">inverse_hyps</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">inversion</span> <span class="id" title="var">MemRel</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">inv</span> <span class="id" title="var">abrel_match_mem_match</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <a class="idref" href="tutorial.stack.Counter.html#get_counter_high_spec"><span class="id" title="definition">get_counter_high_spec</span></a> <span class="id" title="keyword">in</span> <span class="id" title="var">H4</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">assert</span> (<span class="id" title="var">Hz</span>: <span class="id" title="var">z</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <span class="id" title="var">i</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id" title="tactic">rewrite</span> <span class="id" title="var">H4</span> <span class="id" title="keyword">in</span> <span class="id" title="var">H2</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.ZArith.Znat.html#Z2Nat.inj"><span class="id" title="lemma">Z2Nat.inj</span></a> <span class="id" title="keyword">in</span> <span class="id" title="var">H2</span>; <span class="id" title="tactic">try</span> <span class="id" title="tactic">apply</span> <a class="idref" href="compcert.lib.Integers.html#Int.unsigned_range"><span class="id" title="lemma">Int.unsigned_range</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> &lt;- (<a class="idref" href="compcert.lib.Integers.html#Int.repr_unsigned"><span class="id" title="lemma">Int.repr_unsigned</span></a> <span class="id" title="var">z</span>), &lt;- (<a class="idref" href="compcert.lib.Integers.html#Int.repr_unsigned"><span class="id" title="lemma">Int.repr_unsigned</span></a> <span class="id" title="var">i</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">f_equal</span>; <span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">subst</span> <span class="id" title="var">z</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">do</span> 3 <span class="id" title="tactic">eexists</span>; <span class="id" title="tactic">split</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" title="tactic">econstructor</span>; <span class="id" title="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" title="tactic">split</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">constructor</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">split</span>; <span class="id" title="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Qed</span>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Lemma</span> <a name="incr_counter_refine"><span class="id" title="lemma">incr_counter_refine</span></a> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="liblayers.logic.Structures.html#02b32b237357d2b6b54537b4da97c51a"><span class="id" title="notation">(</span></a><a class="idref" href="tutorial.stack.Counter.html#incr_counter"><span class="id" title="definition">incr_counter</span></a> <a class="idref" href="liblayers.logic.Structures.html#33228780c4c171a6131f9e6e62ea2dd4"><span class="id" title="notation">↦</span></a> <a class="idref" href="tutorial.stack.Counter.html#incr_counter_cprimitive"><span class="id" title="definition">incr_counter_cprimitive</span></a><a class="idref" href="liblayers.logic.Structures.html#02b32b237357d2b6b54537b4da97c51a"><span class="id" title="notation">)</span></a> <a class="idref" href="liblayers.logic.Structures.html#02b32b237357d2b6b54537b4da97c51a"><span class="id" title="notation">⊢</span></a> <a class="idref" href="liblayers.logic.Structures.html#02b32b237357d2b6b54537b4da97c51a"><span class="id" title="notation">(</span></a><a class="idref" href="tutorial.stack.Counter.html#counter_R"><span class="id" title="definition">counter_R</span></a><a class="idref" href="liblayers.logic.Structures.html#02b32b237357d2b6b54537b4da97c51a"><span class="id" title="notation">,</span></a> <a class="idref" href="liblayers.logic.Structures.html#1bcfff782645e550303b44d1d50df7a5"><span class="id" title="notation">∅</span></a><a class="idref" href="liblayers.logic.Structures.html#02b32b237357d2b6b54537b4da97c51a"><span class="id" title="notation">)</span></a> <a class="idref" href="liblayers.logic.Structures.html#02b32b237357d2b6b54537b4da97c51a"><span class="id" title="notation">:</span></a> <a class="idref" href="tutorial.stack.Counter.html#incr_counter_layer"><span class="id" title="definition">incr_counter_layer</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>.<br/>
</div>

<div class="doc">
TUTORIAL: Prove that incr_counter_layer simulates the C implementation of incr_counter 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">Admitted</span>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Lemma</span> <a name="decr_counter_refine"><span class="id" title="lemma">decr_counter_refine</span></a> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="liblayers.logic.Structures.html#02b32b237357d2b6b54537b4da97c51a"><span class="id" title="notation">(</span></a><a class="idref" href="tutorial.stack.Counter.html#decr_counter"><span class="id" title="definition">decr_counter</span></a> <a class="idref" href="liblayers.logic.Structures.html#33228780c4c171a6131f9e6e62ea2dd4"><span class="id" title="notation">↦</span></a> <a class="idref" href="tutorial.stack.Counter.html#decr_counter_cprimitive"><span class="id" title="definition">decr_counter_cprimitive</span></a><a class="idref" href="liblayers.logic.Structures.html#02b32b237357d2b6b54537b4da97c51a"><span class="id" title="notation">)</span></a> <a class="idref" href="liblayers.logic.Structures.html#02b32b237357d2b6b54537b4da97c51a"><span class="id" title="notation">⊢</span></a> <a class="idref" href="liblayers.logic.Structures.html#02b32b237357d2b6b54537b4da97c51a"><span class="id" title="notation">(</span></a><a class="idref" href="tutorial.stack.Counter.html#counter_R"><span class="id" title="definition">counter_R</span></a><a class="idref" href="liblayers.logic.Structures.html#02b32b237357d2b6b54537b4da97c51a"><span class="id" title="notation">,</span></a> <a class="idref" href="liblayers.logic.Structures.html#1bcfff782645e550303b44d1d50df7a5"><span class="id" title="notation">∅</span></a><a class="idref" href="liblayers.logic.Structures.html#02b32b237357d2b6b54537b4da97c51a"><span class="id" title="notation">)</span></a> <a class="idref" href="liblayers.logic.Structures.html#02b32b237357d2b6b54537b4da97c51a"><span class="id" title="notation">:</span></a> <a class="idref" href="tutorial.stack.Counter.html#decr_counter_layer"><span class="id" title="definition">decr_counter_layer</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">refine_proof_tac</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">inv</span> <span class="id" title="var">CStep</span>. <span class="id" title="var">inv_generic_sem</span> <span class="id" title="var">H8</span>. <span class="id" title="var">inv_monad</span> <span class="id" title="var">H0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">inverse_hyps</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">inversion</span> <span class="id" title="var">MemRel</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">inv</span> <span class="id" title="var">abrel_match_mem_match</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <a class="idref" href="tutorial.stack.Counter.html#decr_counter_high_spec"><span class="id" title="definition">decr_counter_high_spec</span></a> <span class="id" title="keyword">in</span> <span class="id" title="var">H2</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">destr_in</span> <span class="id" title="var">H2</span>; <span class="id" title="var">inv</span> <span class="id" title="var">H2</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">assert</span> (<span class="id" title="var">Hi_lower</span>: 0 <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.ZArith.BinInt.html#273beba4f3453dbb29192b3ac740bb71"><span class="id" title="notation">&lt;</span></a> <a class="idref" href="compcert.lib.Integers.html#Int.unsigned"><span class="id" title="definition">Int.unsigned</span></a> <span class="id" title="var">i</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id" title="tactic">pose</span> <span class="id" title="var">proof</span> <span class="id" title="var">l</span> <span class="id" title="keyword">as</span> <span class="id" title="var">Hcounter_lower</span>; <span class="id" title="tactic">rewrite</span> <span class="id" title="var">H3</span> <span class="id" title="keyword">in</span> <span class="id" title="var">Hcounter_lower</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.ZArith.Znat.html#Nat2Z.inj_lt"><span class="id" title="lemma">Nat2Z.inj_lt</span></a> <span class="id" title="keyword">in</span> <span class="id" title="var">Hcounter_lower</span>. <span class="id" title="tactic">rewrite</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.ZArith.Znat.html#Z2Nat.id"><span class="id" title="lemma">Z2Nat.id</span></a> <span class="id" title="keyword">in</span> <span class="id" title="var">Hcounter_lower</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" title="tactic">apply</span> <a class="idref" href="compcert.lib.Integers.html#Int.unsigned_range"><span class="id" title="lemma">Int.unsigned_range</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">assert</span> (<span class="id" title="var">Hz</span>: <span class="id" title="var">z</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="compcert.lib.Integers.html#Int.sub"><span class="id" title="definition">Int.sub</span></a> <span class="id" title="var">i</span> <a class="idref" href="compcert.lib.Integers.html#Int.one"><span class="id" title="definition">Int.one</span></a>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id" title="tactic">unfold</span> <a class="idref" href="compcert.lib.Integers.html#Int.sub"><span class="id" title="definition">Int.sub</span></a>, <a class="idref" href="compcert.lib.Integers.html#Int.one"><span class="id" title="definition">Int.one</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">generalize</span> (<a class="idref" href="compcert.lib.Integers.html#Int.unsigned_range"><span class="id" title="lemma">Int.unsigned_range</span></a> <span class="id" title="var">z</span>); <span class="id" title="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <a class="idref" href="compcert.lib.Integers.html#Int.unsigned_repr"><span class="id" title="lemma">Int.unsigned_repr</span></a>; [| <span class="id" title="var">cbn</span>; <span class="id" title="tactic">omega</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> &lt;- (<a class="idref" href="compcert.lib.Integers.html#Int.repr_unsigned"><span class="id" title="lemma">Int.repr_unsigned</span></a> <span class="id" title="var">z</span>); <span class="id" title="tactic">f_equal</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.ZArith.Znat.html#Z2Nat.inj"><span class="id" title="lemma">Z2Nat.inj</span></a>; <span class="id" title="tactic">try</span> <span class="id" title="tactic">omega</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> &lt;- <span class="id" title="var">H6</span>. <span class="id" title="tactic">rewrite</span> <span class="id" title="var">H3</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.ZArith.Znat.html#Z2Nat.inj_sub"><span class="id" title="lemma">Z2Nat.inj_sub</span></a>; [<span class="id" title="tactic">reflexivity</span> | <span class="id" title="tactic">omega</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">subst</span> <span class="id" title="var">z</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> (<a class="idref" href="compcert.common.Memtype.html#Mem.valid_access_store"><span class="id" title="lemma">Mem.valid_access_store</span></a> <span class="id" title="var">ym</span> <a class="idref" href="compcert.common.AST.html#Mint32"><span class="id" title="constructor">Mint32</span></a> <span class="id" title="var">b</span> 0 (<a class="idref" href="compcert.common.Values.html#Vint"><span class="id" title="constructor">Vint</span></a> (<a class="idref" href="compcert.lib.Integers.html#Int.sub"><span class="id" title="definition">Int.sub</span></a> <span class="id" title="var">i</span> <a class="idref" href="compcert.lib.Integers.html#Int.one"><span class="id" title="definition">Int.one</span></a>)))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">as</span> (<span class="id" title="var">m'</span> &amp; <span class="id" title="var">Hstore</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id" title="tactic">split</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" title="tactic">eapply</span> (<span class="id" title="var">abrel_match_mem_perms</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> 0 <a class="idref" href="compcert.common.Memtype.html#Cur"><span class="id" title="constructor">Cur</span></a> <a class="idref" href="compcert.common.Memtype.html#Writable"><span class="id" title="constructor">Writable</span></a>) <span class="id" title="keyword">in</span> <span class="id" title="var">H0</span>; <span class="id" title="var">now</span> <span class="id" title="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" title="tactic">apply</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.ZArith.BinInt.html#Z.divide_0_r"><span class="id" title="lemma">Z.divide_0_r</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">do</span> 3 <span class="id" title="tactic">eexists</span>; <span class="id" title="tactic">split</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" title="tactic">econstructor</span>; <span class="id" title="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" title="tactic">split</span>; <span class="id" title="var">cbn</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">constructor</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">split</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;× <span class="id" title="tactic">eapply</span> <a class="idref" href="compcert.common.Memtype.html#Mem.store_outside_extends"><span class="id" title="method">Mem.store_outside_extends</span></a>; <span class="id" title="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="tactic">eapply</span> <span class="id" title="var">abrel_match_mem_perms</span> <span class="id" title="keyword">in</span> <span class="id" title="var">H2</span>; <span class="id" title="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;× <span class="id" title="tactic">constructor</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ </div>

<div class="doc">
Abs data relate 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">constructor</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ </div>

<div class="doc">
High abs data matches low memory 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">cbn</span>. <span class="id" title="tactic">econstructor</span>; <span class="id" title="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">erewrite</span> <a class="idref" href="compcert.common.Memtype.html#Mem.load_store_same"><span class="id" title="method">Mem.load_store_same</span></a>; <span class="id" title="var">cbn</span>; <span class="id" title="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ </div>

<div class="doc">
Global variable permissions 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">cbn</span>; <span class="id" title="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">specialize</span> (<span class="id" title="var">abrel_match_mem_perms</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">ofs</span> <span class="id" title="var">k</span> <span class="id" title="var">p</span> <span class="id" title="var">H2</span> <span class="id" title="var">H4</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">abrel_match_mem_perms</span> <span class="id" title="keyword">as</span> (<span class="id" title="var">NP</span> &amp; <span class="id" title="var">P</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">split</span>; <span class="id" title="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">red</span>; <span class="id" title="tactic">intros</span>. <span class="id" title="tactic">eapply</span> <a class="idref" href="compcert.common.Memtype.html#Mem.perm_store_1"><span class="id" title="method">Mem.perm_store_1</span></a>; <span class="id" title="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ </div>

<div class="doc">
Global variable memory blocks are valid 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> (<a class="idref" href="compcert.common.Memtype.html#Mem.nextblock_store"><span class="id" title="method">Mem.nextblock_store</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">Hstore</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Qed</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">End</span> <a class="idref" href="tutorial.stack.Counter.html#Counter.LowHighSpecSim"><span class="id" title="section">LowHighSpecSim</span></a>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab700"></a><h2 class="section">Linking</h2>

</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="keyword">Section</span> <a name="Counter.Linking"><span class="id" title="section">Linking</span></a>.<br/>

<br/>
</div>

<div class="doc">
We can now define the complete Counter layer by composing the high
      level specs. 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <a name="counter_L"><span class="id" title="definition">counter_L</span></a> : <a class="idref" href="liblayers.compcertx.CPrimitives.html#clayer"><span class="id" title="abbreviation">clayer</span></a> <a class="idref" href="tutorial.stack.Counter.html#counter_layerdata"><span class="id" title="definition">counter_layerdata</span></a> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="tutorial.stack.Counter.html#get_counter_layer"><span class="id" title="definition">get_counter_layer</span></a> <a class="idref" href="liblayers.logic.Structures.html#64a6660c5ed3e47856f7e7c848c9c807"><span class="id" title="notation">⊕</span></a> <a class="idref" href="tutorial.stack.Counter.html#incr_counter_layer"><span class="id" title="definition">incr_counter_layer</span></a> <a class="idref" href="liblayers.logic.Structures.html#64a6660c5ed3e47856f7e7c848c9c807"><span class="id" title="notation">⊕</span></a> <a class="idref" href="tutorial.stack.Counter.html#decr_counter_layer"><span class="id" title="definition">decr_counter_layer</span></a>.<br/>

<br/>
</div>

<div class="doc">
The low level specs (often represented as <span class="inlinecode">σ</span>, hence <span class="inlinecode"><a class="idref" href="tutorial.common.TutoLib.html#e15c0eb40e61adefe95778c26e7840f6"><span class="id" title="variable">Σ</span></a></span> for their
      composition) also form an intermediate layer between <span class="inlinecode"><a class="idref" href="tutorial.stack.Counter.html#base_L"><span class="id" title="definition">base_L</span></a></span> and
      <span class="inlinecode"><a class="idref" href="tutorial.stack.Counter.html#counter_L"><span class="id" title="definition">counter_L</span></a></span>. 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <a name="ca4a04e7274e381ac0e301a297e6dfdd"><span class="id" title="definition">counter_Σ</span></a> : <a class="idref" href="liblayers.compcertx.CPrimitives.html#clayer"><span class="id" title="abbreviation">clayer</span></a> <a class="idref" href="tutorial.stack.Counter.html#base_layerdata"><span class="id" title="definition">base_layerdata</span></a> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="tutorial.stack.Counter.html#get_counter"><span class="id" title="definition">get_counter</span></a> <a class="idref" href="liblayers.logic.Structures.html#33228780c4c171a6131f9e6e62ea2dd4"><span class="id" title="notation">↦</span></a> <a class="idref" href="tutorial.stack.Counter.html#get_counter_cprimitive"><span class="id" title="definition">get_counter_cprimitive</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="liblayers.logic.Structures.html#64a6660c5ed3e47856f7e7c848c9c807"><span class="id" title="notation">⊕</span></a> <a class="idref" href="tutorial.stack.Counter.html#incr_counter"><span class="id" title="definition">incr_counter</span></a> <a class="idref" href="liblayers.logic.Structures.html#33228780c4c171a6131f9e6e62ea2dd4"><span class="id" title="notation">↦</span></a> <a class="idref" href="tutorial.stack.Counter.html#incr_counter_cprimitive"><span class="id" title="definition">incr_counter_cprimitive</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="liblayers.logic.Structures.html#64a6660c5ed3e47856f7e7c848c9c807"><span class="id" title="notation">⊕</span></a> <a class="idref" href="tutorial.stack.Counter.html#decr_counter"><span class="id" title="definition">decr_counter</span></a> <a class="idref" href="liblayers.logic.Structures.html#33228780c4c171a6131f9e6e62ea2dd4"><span class="id" title="notation">↦</span></a> <a class="idref" href="tutorial.stack.Counter.html#decr_counter_cprimitive"><span class="id" title="definition">decr_counter_cprimitive</span></a>).<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <a name="counter_M"><span class="id" title="definition">counter_M</span></a> : <a class="idref" href="liblayers.compcertx.ClightModules.html#cmodule"><span class="id" title="abbreviation">cmodule</span></a> := <a class="idref" href="tutorial.stack.Counter.html#Mget"><span class="id" title="definition">Mget</span></a> <a class="idref" href="liblayers.logic.Structures.html#64a6660c5ed3e47856f7e7c848c9c807"><span class="id" title="notation">⊕</span></a> <a class="idref" href="tutorial.stack.Counter.html#Mincr"><span class="id" title="definition">Mincr</span></a> <a class="idref" href="liblayers.logic.Structures.html#64a6660c5ed3e47856f7e7c848c9c807"><span class="id" title="notation">⊕</span></a> <a class="idref" href="tutorial.stack.Counter.html#Mdecr"><span class="id" title="definition">Mdecr</span></a>.<br/>

<br/>
</div>

<div class="doc">
As a last step, we must horizontally and vertically compose the
      code and refinement proofs we have done so far for individual primitives.
      The result is a statement that the C code in <span class="inlinecode"><a class="idref" href="tutorial.stack.Counter.html#counter_M"><span class="id" title="definition">counter_M</span></a></span> evaluated on top
      of <span class="inlinecode"><a class="idref" href="tutorial.stack.Counter.html#base_L"><span class="id" title="definition">base_L</span></a></span> refines the behaviours specified by the specs in <span class="inlinecode"><a class="idref" href="tutorial.stack.Counter.html#counter_L"><span class="id" title="definition">counter_L</span></a></span>.
      This means that other layers that build on this one can write primitives
      in terms of the high level specs in <span class="inlinecode"><a class="idref" href="tutorial.stack.Counter.html#counter_L"><span class="id" title="definition">counter_L</span></a></span> and be sure that any
      properties proved will still hold in the C implementation. 
<div class="paragraph"> </div>

 This linking step is usually fairly mechanical and can be largely
      automated using custom tactics and hint databases. Here we show the proof
      both with and without automation. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Theorem</span> <a name="counter_link"><span class="id" title="lemma">counter_link</span></a> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="tutorial.stack.Counter.html#base_L"><span class="id" title="definition">base_L</span></a> <a class="idref" href="liblayers.logic.Structures.html#02b32b237357d2b6b54537b4da97c51a"><span class="id" title="notation">⊢</span></a> <a class="idref" href="liblayers.logic.Structures.html#02b32b237357d2b6b54537b4da97c51a"><span class="id" title="notation">(</span></a><a class="idref" href="tutorial.stack.Counter.html#counter_R"><span class="id" title="definition">counter_R</span></a><a class="idref" href="liblayers.logic.Structures.html#02b32b237357d2b6b54537b4da97c51a"><span class="id" title="notation">,</span></a> <a class="idref" href="tutorial.stack.Counter.html#counter_M"><span class="id" title="definition">counter_M</span></a><a class="idref" href="liblayers.logic.Structures.html#02b32b237357d2b6b54537b4da97c51a"><span class="id" title="notation">)</span></a> <a class="idref" href="liblayers.logic.Structures.html#02b32b237357d2b6b54537b4da97c51a"><span class="id" title="notation">:</span></a> <a class="idref" href="tutorial.stack.Counter.html#counter_L"><span class="id" title="definition">counter_L</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>.<br/>
</div>

<div class="doc">
We want to prove the linking in two steps:
<ul class="doclist">
<li> <span class="inlinecode"><a class="idref" href="tutorial.stack.Counter.html#base_L"><span class="id" title="definition">base_L</span></a></span> <span class="inlinecode">⊢</span> <span class="inlinecode">(<a class="idref" href="liblayers.logic.Structures.html#id"><span class="id" title="projection">id</span></a>,</span> <span class="inlinecode"><a class="idref" href="tutorial.stack.Counter.html#counter_M"><span class="id" title="definition">counter_M</span></a>)</span> <span class="inlinecode">:</span> <span class="inlinecode"><a class="idref" href="tutorial.stack.Counter.html#ca4a04e7274e381ac0e301a297e6dfdd"><span class="id" title="definition">counter_Σ</span></a></span>

</li>
<li> <span class="inlinecode"><a class="idref" href="tutorial.stack.Counter.html#ca4a04e7274e381ac0e301a297e6dfdd"><span class="id" title="definition">counter_Σ</span></a></span> <span class="inlinecode">⊢</span> <span class="inlinecode">(<a class="idref" href="tutorial.stack.Counter.html#counter_R"><span class="id" title="definition">counter_R</span></a>,</span> <span class="inlinecode">∅)</span> <span class="inlinecode">:</span> <span class="inlinecode"><a class="idref" href="tutorial.stack.Counter.html#counter_L"><span class="id" title="definition">counter_L</span></a></span>

</li>
</ul>

<div class="paragraph"> </div>

        So first we must rewrite <span class="inlinecode"><a class="idref" href="tutorial.stack.Counter.html#counter_R"><span class="id" title="definition">counter_R</span></a></span> so it is composed with <span class="inlinecode"><a class="idref" href="liblayers.logic.Structures.html#id"><span class="id" title="projection">id</span></a></span> on the
        left, and <span class="inlinecode"><a class="idref" href="tutorial.stack.Counter.html#counter_M"><span class="id" title="definition">counter_M</span></a></span> so it is composed with the empty module on the
        right. 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<a class="idref" href="liblayers.logic.Language.html#vdash_rel_equiv"><span class="id" title="method">vdash_rel_equiv</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> (<a class="idref" href="liblayers.logic.Structures.html#id"><span class="id" title="method">id</span></a> <a class="idref" href="liblayers.logic.Structures.html#28309b4b31fc061cea0bf998329431b2"><span class="id" title="notation">∘</span></a> <a class="idref" href="tutorial.stack.Counter.html#counter_R"><span class="id" title="definition">counter_R</span></a>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id" title="tactic">apply</span> <a class="idref" href="liblayers.logic.LayerData.html#cat_compose_id_left"><span class="id" title="method">cat_compose_id_left</span></a>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<a class="idref" href="liblayers.logic.Language.html#vdash_module_le"><span class="id" title="method">vdash_module_le</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> (<a class="idref" href="tutorial.stack.Counter.html#counter_M"><span class="id" title="definition">counter_M</span></a> <a class="idref" href="liblayers.logic.Structures.html#64a6660c5ed3e47856f7e7c848c9c807"><span class="id" title="notation">⊕</span></a> <a class="idref" href="liblayers.logic.Structures.html#1bcfff782645e550303b44d1d50df7a5"><span class="id" title="notation">∅</span></a>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">constructor</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
</div>

<div class="doc">
Now we can use the vertical composition rule to split our goal. 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<a class="idref" href="liblayers.logic.Language.html#vcomp_rule"><span class="id" title="method">vcomp_rule</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <a class="idref" href="tutorial.stack.Counter.html#ca4a04e7274e381ac0e301a297e6dfdd"><span class="id" title="definition">counter_Σ</span></a>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">constructor</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- </div>

<div class="doc">
Then we want to split the modules and low level specs into
          the individual primitives so we can apply the code proofs
          we did before. 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <a class="idref" href="liblayers.logic.Language.html#hcomp_rule"><span class="id" title="method">hcomp_rule</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">constructor</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">apply</span> <a class="idref" href="tutorial.stack.Counter.html#get_counter_code"><span class="id" title="lemma">get_counter_code</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">apply</span> <a class="idref" href="liblayers.logic.Language.html#hcomp_rule"><span class="id" title="method">hcomp_rule</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">constructor</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <a class="idref" href="tutorial.stack.Counter.html#incr_counter_code"><span class="id" title="axiom">incr_counter_code</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <a class="idref" href="tutorial.stack.Counter.html#decr_counter_code"><span class="id" title="lemma">decr_counter_code</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- </div>

<div class="doc">
For the refinement portion we have the empty module because no
          extra code is needed to abstract from the low to the high level
          specs. <span class="inlinecode"><span class="id" title="var">pjr</span></span> is a reflection tactic that can solve goals involving
          <span class="inlinecode">⊕</span> and <span class="inlinecode">≤</span>. 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <a class="idref" href="tutorial.stack.Counter.html#ca4a04e7274e381ac0e301a297e6dfdd"><span class="id" title="definition">counter_Σ</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<a class="idref" href="liblayers.logic.Language.html#vdash_module_le"><span class="id" title="method">vdash_module_le</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> (<a class="idref" href="liblayers.logic.Structures.html#1bcfff782645e550303b44d1d50df7a5"><span class="id" title="notation">∅</span></a> <a class="idref" href="liblayers.logic.Structures.html#64a6660c5ed3e47856f7e7c848c9c807"><span class="id" title="notation">⊕</span></a> <a class="idref" href="liblayers.logic.Structures.html#1bcfff782645e550303b44d1d50df7a5"><span class="id" title="notation">∅</span></a>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">constructor</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <a class="idref" href="liblayers.logic.Language.html#hcomp_rule"><span class="id" title="method">hcomp_rule</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">constructor</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">eapply</span> <a class="idref" href="liblayers.logic.Language.html#conseq_le_left"><span class="id" title="lemma">conseq_le_left</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">constructor</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;× <span class="id" title="tactic">apply</span> <a class="idref" href="tutorial.stack.Counter.html#get_counter_refine"><span class="id" title="lemma">get_counter_refine</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;× <span class="id" title="var">pjr</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">apply</span> (<a class="idref" href="liblayers.logic.Language.html#vdash_module_le"><span class="id" title="method">vdash_module_le</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> (<a class="idref" href="liblayers.logic.Structures.html#1bcfff782645e550303b44d1d50df7a5"><span class="id" title="notation">∅</span></a> <a class="idref" href="liblayers.logic.Structures.html#64a6660c5ed3e47856f7e7c848c9c807"><span class="id" title="notation">⊕</span></a> <a class="idref" href="liblayers.logic.Structures.html#1bcfff782645e550303b44d1d50df7a5"><span class="id" title="notation">∅</span></a>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">constructor</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <a class="idref" href="liblayers.logic.Language.html#hcomp_rule"><span class="id" title="method">hcomp_rule</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">constructor</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;× <span class="id" title="tactic">eapply</span> <a class="idref" href="liblayers.logic.Language.html#conseq_le_left"><span class="id" title="lemma">conseq_le_left</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">constructor</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-- <span class="id" title="tactic">apply</span> <a class="idref" href="tutorial.stack.Counter.html#incr_counter_refine"><span class="id" title="axiom">incr_counter_refine</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-- <span class="id" title="var">pjr</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;× <span class="id" title="tactic">eapply</span> <a class="idref" href="liblayers.logic.Language.html#conseq_le_left"><span class="id" title="lemma">conseq_le_left</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">constructor</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-- <span class="id" title="tactic">apply</span> <a class="idref" href="tutorial.stack.Counter.html#decr_counter_refine"><span class="id" title="lemma">decr_counter_refine</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-- <span class="id" title="var">pjr</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Qed</span>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Hint Resolve</span> <span class="id" title="var">get_counter_code</span> <span class="id" title="var">get_counter_refine</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">incr_counter_code</span> <span class="id" title="var">incr_counter_refine</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">decr_counter_code</span> <span class="id" title="var">decr_counter_refine</span> : <span class="id" title="var">linking</span>.<br/>

<br/>
</div>

<div class="doc">
The tactic <span class="inlinecode"><span class="id" title="var">link_tac</span></span> essentially repeats the steps seen in the manual
      proof as many times as necessary and uses the <span class="inlinecode"><span class="id" title="var">linking</span></span> Hint database to
      figure out which code and refinement proofs to use. 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Theorem</span> <a name="counter_link_auto"><span class="id" title="lemma">counter_link_auto</span></a> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="tutorial.stack.Counter.html#base_L"><span class="id" title="definition">base_L</span></a> <a class="idref" href="liblayers.logic.Structures.html#02b32b237357d2b6b54537b4da97c51a"><span class="id" title="notation">⊢</span></a> <a class="idref" href="liblayers.logic.Structures.html#02b32b237357d2b6b54537b4da97c51a"><span class="id" title="notation">(</span></a><a class="idref" href="tutorial.stack.Counter.html#counter_R"><span class="id" title="definition">counter_R</span></a><a class="idref" href="liblayers.logic.Structures.html#02b32b237357d2b6b54537b4da97c51a"><span class="id" title="notation">,</span></a> <a class="idref" href="tutorial.stack.Counter.html#counter_M"><span class="id" title="definition">counter_M</span></a><a class="idref" href="liblayers.logic.Structures.html#02b32b237357d2b6b54537b4da97c51a"><span class="id" title="notation">)</span></a> <a class="idref" href="liblayers.logic.Structures.html#02b32b237357d2b6b54537b4da97c51a"><span class="id" title="notation">:</span></a> <a class="idref" href="tutorial.stack.Counter.html#counter_L"><span class="id" title="definition">counter_L</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>. <span class="id" title="var">link_tac</span> <a class="idref" href="tutorial.stack.Counter.html#ca4a04e7274e381ac0e301a297e6dfdd"><span class="id" title="definition">counter_Σ</span></a>. <span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<span class="inlinecode"><a class="idref" href="liblayers.logic.Layers.html#ForallPrimitive"><span class="id" title="record">ForallPrimitive</span></a></span> allows us to state properties that hold for every
      primitive in a layer. We want to use it here to check that everything in
      the layer preserves its invariants. This can be solved automatically with
      <span class="inlinecode"><span class="id" title="var">typeclasses</span></span> <span class="inlinecode"><span class="id" title="tactic">eauto</span></span> (assuming of course that an instance of
      <span class="inlinecode"><a class="idref" href="liblayers.compcertx.CPrimitives.html#CPrimitivePreservesInvariant"><span class="id" title="record">CPrimitivePreservesInvariant</span></a></span> actually exists for each primitive. A
      little unfolding might be necessary to help the proof search recognize
      the structure of the layer. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Lemma</span> <a name="base_pres_inv"><span class="id" title="lemma">base_pres_inv</span></a> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="liblayers.logic.Layers.html#ForallPrimitive"><span class="id" title="class">ForallPrimitive</span></a> <span class="id" title="var">_</span> (<a class="idref" href="liblayers.compcertx.CPrimitives.html#CPrimitivePreservesInvariant"><span class="id" title="class">CPrimitivePreservesInvariant</span></a> <span class="id" title="var">_</span>) <a class="idref" href="tutorial.stack.Counter.html#base_L"><span class="id" title="definition">base_L</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>. <span class="id" title="var">typeclasses</span> <span class="id" title="tactic">eauto</span>. <span class="id" title="keyword">Qed</span>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Lemma</span> <a name="counter_pres_inv"><span class="id" title="lemma">counter_pres_inv</span></a> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="liblayers.logic.Layers.html#ForallPrimitive"><span class="id" title="class">ForallPrimitive</span></a> <span class="id" title="var">_</span> (<a class="idref" href="liblayers.compcertx.CPrimitives.html#CPrimitivePreservesInvariant"><span class="id" title="class">CPrimitivePreservesInvariant</span></a> <span class="id" title="var">_</span>) <a class="idref" href="tutorial.stack.Counter.html#counter_L"><span class="id" title="definition">counter_L</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">unfold</span> <a class="idref" href="tutorial.stack.Counter.html#counter_L"><span class="id" title="definition">counter_L</span></a>. <span class="id" title="var">typeclasses</span> <span class="id" title="tactic">eauto</span>. <span class="id" title="keyword">Qed</span>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Hint Resolve</span> <span class="id" title="var">base_pres_inv</span> <span class="id" title="var">counter_pres_inv</span> <span class="id" title="var">counter_link</span> : <span class="id" title="var">linking</span>.<br/>

<br/>
</div>

<div class="doc">
Although we did not need to make use of the layer invariant in order to
      complete our simulation proofs, because we know that each of our
      primitives preserves the invariants, we can prove that the linking still
      holds when we require that the invariants of the under- and overlay are
      preserved. 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Theorem</span> <a name="counter_link_inv"><span class="id" title="lemma">counter_link_inv</span></a> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="tutorial.stack.Counter.html#base_L"><span class="id" title="definition">base_L</span></a> <a class="idref" href="liblayers.logic.Structures.html#02b32b237357d2b6b54537b4da97c51a"><span class="id" title="notation">⊢</span></a> <a class="idref" href="liblayers.logic.Structures.html#02b32b237357d2b6b54537b4da97c51a"><span class="id" title="notation">(</span></a><a class="idref" href="liblayers.simrel.SimrelInvariant.html#inv"><span class="id" title="definition">inv</span></a> <a class="idref" href="liblayers.logic.Structures.html#28309b4b31fc061cea0bf998329431b2"><span class="id" title="notation">∘</span></a> <a class="idref" href="tutorial.stack.Counter.html#counter_R"><span class="id" title="definition">counter_R</span></a> <a class="idref" href="liblayers.logic.Structures.html#28309b4b31fc061cea0bf998329431b2"><span class="id" title="notation">∘</span></a> <a class="idref" href="liblayers.simrel.SimrelInvariant.html#inv"><span class="id" title="definition">inv</span></a><a class="idref" href="liblayers.logic.Structures.html#02b32b237357d2b6b54537b4da97c51a"><span class="id" title="notation">,</span></a> <a class="idref" href="tutorial.stack.Counter.html#counter_M"><span class="id" title="definition">counter_M</span></a><a class="idref" href="liblayers.logic.Structures.html#02b32b237357d2b6b54537b4da97c51a"><span class="id" title="notation">)</span></a> <a class="idref" href="liblayers.logic.Structures.html#02b32b237357d2b6b54537b4da97c51a"><span class="id" title="notation">:</span></a> <a class="idref" href="tutorial.stack.Counter.html#counter_L"><span class="id" title="definition">counter_L</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <a class="idref" href="liblayers.logic.Language.html#conseq_rule"><span class="id" title="method">conseq_rule</span></a> <span class="id" title="keyword">with</span> <a class="idref" href="tutorial.stack.Counter.html#base_L"><span class="id" title="definition">base_L</span></a> <a class="idref" href="tutorial.stack.Counter.html#counter_L"><span class="id" title="definition">counter_L</span></a>; [<span class="id" title="tactic">constructor</span> | | |]; <span class="id" title="tactic">auto</span> <span class="id" title="keyword">with</span> <span class="id" title="var">linking</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Qed</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">End</span> <a class="idref" href="tutorial.stack.Counter.html#Counter.Linking"><span class="id" title="section">Linking</span></a>.<br/>

<br/>
<span class="id" title="keyword">End</span> <a class="idref" href="tutorial.stack.Counter.html#Counter"><span class="id" title="section">Counter</span></a>.<br/>
</div>
</div>

<div id="footer">
<hr/><a href="index.html">Index</a><hr/>This page has been generated by <a href="http://coq.inria.fr/">coqdoc</a>
</div>

</div>

</body>
</html>