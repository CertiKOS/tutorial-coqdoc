<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link href="coqdoc.css" rel="stylesheet" type="text/css" />
<title>liblayers.simrel.MemOpv</title>
</head>

<body>

<div id="page">

<div id="header">
</div>

<div id="main">

<h1 class="libtitle">Library liblayers.simrel.MemOpv</h1>

<div class="code">
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Export</span> <a class="idref" href="compcert.lib.Coqlib.html#"><span class="id" title="library">compcert.lib.Coqlib</span></a>.<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Export</span> <a class="idref" href="compcert.lib.Integers.html#"><span class="id" title="library">compcert.lib.Integers</span></a>.<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Export</span> <a class="idref" href="compcert.common.Values.html#"><span class="id" title="library">compcert.common.Values</span></a>.<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Export</span> <a class="idref" href="compcertx.common.MemoryX.html#"><span class="id" title="library">compcertx.common.MemoryX</span></a>.<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="liblayers.lib.ExtensionalityAxioms.html#"><span class="id" title="library">ExtensionalityAxioms</span></a>.<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="liblayers.simrel.SimrelDefinition.html#"><span class="id" title="library">SimrelDefinition</span></a>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab497"></a><h1 class="section">Memory operation helpers</h1>

<div class="paragraph"> </div>

 Define some more int-based operations in the flavour of Mem.loadv,
   Mem.storev, etc. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Module</span> <a name="Mem"><span class="id" title="module">Mem</span></a>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Export</span> <span class="id" title="var">MemoryX.Mem</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Section</span> <a name="Mem.WITHMEMORYMODELOPS"><span class="id" title="section">WITHMEMORYMODELOPS</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Context</span> `{<span class="id" title="var">memory_model_ops</span>: <a class="idref" href="compcert.common.Memtype.html#Mem.MemoryModelOps"><span class="id" title="class">MemoryModelOps</span></a>}.<br/>

<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <a name="Mem.loadbytesv"><span class="id" title="definition">loadbytesv</span></a> <span class="id" title="var">m</span> <span class="id" title="var">v</span> <span class="id" title="var">sz</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="liblayers.simrel.MemOpv.html#v"><span class="id" title="variable">v</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="compcert.common.Values.html#Vptr"><span class="id" title="constructor">Vptr</span></a> <span class="id" title="var">b</span> <span class="id" title="var">o</span> ⇒ <a class="idref" href="compcert.common.Memtype.html#Mem.loadbytes"><span class="id" title="method">loadbytes</span></a> <a class="idref" href="liblayers.simrel.MemOpv.html#m"><span class="id" title="variable">m</span></a> <span class="id" title="var">b</span> (<a class="idref" href="compcert.lib.Integers.html#Ptrofs.unsigned"><span class="id" title="definition">Ptrofs.unsigned</span></a> <span class="id" title="var">o</span>) <a class="idref" href="liblayers.simrel.MemOpv.html#sz"><span class="id" title="variable">sz</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">_</span> ⇒ <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#None"><span class="id" title="constructor">None</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <a name="Mem.storebytesv"><span class="id" title="definition">storebytesv</span></a> <span class="id" title="var">m</span> <span class="id" title="var">v</span> <span class="id" title="var">v'</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="liblayers.simrel.MemOpv.html#v"><span class="id" title="variable">v</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="compcert.common.Values.html#Vptr"><span class="id" title="constructor">Vptr</span></a> <span class="id" title="var">b</span> <span class="id" title="var">o</span> ⇒ <a class="idref" href="compcert.common.Memtype.html#Mem.storebytes"><span class="id" title="method">storebytes</span></a> <a class="idref" href="liblayers.simrel.MemOpv.html#m"><span class="id" title="variable">m</span></a> <span class="id" title="var">b</span> (<a class="idref" href="compcert.lib.Integers.html#Ptrofs.unsigned"><span class="id" title="definition">Ptrofs.unsigned</span></a> <span class="id" title="var">o</span>) <a class="idref" href="liblayers.simrel.MemOpv.html#v'"><span class="id" title="variable">v'</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">_</span> ⇒ <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#None"><span class="id" title="constructor">None</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <a name="Mem.permv"><span class="id" title="definition">permv</span></a> <span class="id" title="var">m</span> <span class="id" title="var">v</span> <span class="id" title="var">p</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="liblayers.simrel.MemOpv.html#v"><span class="id" title="variable">v</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="compcert.common.Values.html#Vptr"><span class="id" title="constructor">Vptr</span></a> <span class="id" title="var">b</span> <span class="id" title="var">o</span> ⇒ <a class="idref" href="compcert.common.Memtype.html#Mem.perm"><span class="id" title="method">perm</span></a> <a class="idref" href="liblayers.simrel.MemOpv.html#m"><span class="id" title="variable">m</span></a> <span class="id" title="var">b</span> (<a class="idref" href="compcert.lib.Integers.html#Ptrofs.unsigned"><span class="id" title="definition">Ptrofs.unsigned</span></a> <span class="id" title="var">o</span>) <a class="idref" href="compcert.common.Memtype.html#Cur"><span class="id" title="constructor">Cur</span></a> <a class="idref" href="liblayers.simrel.MemOpv.html#p"><span class="id" title="variable">p</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">_</span> ⇒ <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#False"><span class="id" title="inductive">False</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <a name="Mem.range_permv"><span class="id" title="definition">range_permv</span></a> <span class="id" title="var">m</span> <span class="id" title="var">v</span> <span class="id" title="var">sz</span> <span class="id" title="var">p</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="liblayers.simrel.MemOpv.html#v"><span class="id" title="variable">v</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="compcert.common.Values.html#Vptr"><span class="id" title="constructor">Vptr</span></a> <span class="id" title="var">b</span> <span class="id" title="var">o</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="compcert.common.Memtype.html#Mem.range_perm"><span class="id" title="method">range_perm</span></a> <a class="idref" href="liblayers.simrel.MemOpv.html#m"><span class="id" title="variable">m</span></a> <span class="id" title="var">b</span> (<a class="idref" href="compcert.lib.Integers.html#Ptrofs.unsigned"><span class="id" title="definition">Ptrofs.unsigned</span></a> <span class="id" title="var">o</span>) (<a class="idref" href="compcert.lib.Integers.html#Ptrofs.unsigned"><span class="id" title="definition">Ptrofs.unsigned</span></a> <span class="id" title="var">o</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.ZArith.BinInt.html#a3448b794f7a26d611ad36492b5d640b"><span class="id" title="notation">+</span></a> <a class="idref" href="liblayers.simrel.MemOpv.html#sz"><span class="id" title="variable">sz</span></a>) <a class="idref" href="compcert.common.Memtype.html#Cur"><span class="id" title="constructor">Cur</span></a> <a class="idref" href="liblayers.simrel.MemOpv.html#p"><span class="id" title="variable">p</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">_</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#False"><span class="id" title="inductive">False</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <a name="Mem.disjoint_or_equal"><span class="id" title="definition">disjoint_or_equal</span></a> <span class="id" title="var">sz</span> <span class="id" title="var">m</span> (<span class="id" title="var">b1</span>: <a class="idref" href="compcert.common.Values.html#block"><span class="id" title="definition">block</span></a>) <span class="id" title="var">ofs1</span> <span class="id" title="var">b2</span> <span class="id" title="var">ofs2</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="liblayers.simrel.MemOpv.html#sz"><span class="id" title="variable">sz</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.ZArith.BinInt.html#162be8364124d2d389b2e8a3fc881ab2"><span class="id" title="notation">≥</span></a> 0 <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d82a7d96d3659d805ffe732283716822"><span class="id" title="notation">∧</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="compcert.common.Memtype.html#Mem.range_perm"><span class="id" title="method">Mem.range_perm</span></a> <a class="idref" href="liblayers.simrel.MemOpv.html#m"><span class="id" title="variable">m</span></a> <a class="idref" href="liblayers.simrel.MemOpv.html#b1"><span class="id" title="variable">b1</span></a> <a class="idref" href="liblayers.simrel.MemOpv.html#ofs1"><span class="id" title="variable">ofs1</span></a> (<a class="idref" href="liblayers.simrel.MemOpv.html#ofs1"><span class="id" title="variable">ofs1</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.ZArith.BinInt.html#a3448b794f7a26d611ad36492b5d640b"><span class="id" title="notation">+</span></a> <a class="idref" href="liblayers.simrel.MemOpv.html#sz"><span class="id" title="variable">sz</span></a>) <a class="idref" href="compcert.common.Memtype.html#Cur"><span class="id" title="constructor">Cur</span></a> <a class="idref" href="compcert.common.Memtype.html#Nonempty"><span class="id" title="constructor">Nonempty</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d82a7d96d3659d805ffe732283716822"><span class="id" title="notation">∧</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="compcert.common.Memtype.html#Mem.range_perm"><span class="id" title="method">Mem.range_perm</span></a> <a class="idref" href="liblayers.simrel.MemOpv.html#m"><span class="id" title="variable">m</span></a> <a class="idref" href="liblayers.simrel.MemOpv.html#b2"><span class="id" title="variable">b2</span></a> <a class="idref" href="liblayers.simrel.MemOpv.html#ofs2"><span class="id" title="variable">ofs2</span></a> (<a class="idref" href="liblayers.simrel.MemOpv.html#ofs2"><span class="id" title="variable">ofs2</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.ZArith.BinInt.html#a3448b794f7a26d611ad36492b5d640b"><span class="id" title="notation">+</span></a> <a class="idref" href="liblayers.simrel.MemOpv.html#sz"><span class="id" title="variable">sz</span></a>) <a class="idref" href="compcert.common.Memtype.html#Cur"><span class="id" title="constructor">Cur</span></a> <a class="idref" href="compcert.common.Memtype.html#Nonempty"><span class="id" title="constructor">Nonempty</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d82a7d96d3659d805ffe732283716822"><span class="id" title="notation">∧</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d82a7d96d3659d805ffe732283716822"><span class="id" title="notation">(</span></a><a class="idref" href="liblayers.simrel.MemOpv.html#b1"><span class="id" title="variable">b1</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#32263a1c8b01baecdff9deb038955bc9"><span class="id" title="notation">≠</span></a> <a class="idref" href="liblayers.simrel.MemOpv.html#b2"><span class="id" title="variable">b2</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">∨</span></a> <a class="idref" href="liblayers.simrel.MemOpv.html#ofs1"><span class="id" title="variable">ofs1</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="liblayers.simrel.MemOpv.html#ofs2"><span class="id" title="variable">ofs2</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">∨</span></a> <a class="idref" href="liblayers.simrel.MemOpv.html#ofs1"><span class="id" title="variable">ofs1</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.ZArith.BinInt.html#a3448b794f7a26d611ad36492b5d640b"><span class="id" title="notation">+</span></a> <a class="idref" href="liblayers.simrel.MemOpv.html#sz"><span class="id" title="variable">sz</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.ZArith.BinInt.html#208bafb0e148fe7fb7dcd812c227f4ee"><span class="id" title="notation">≤</span></a> <a class="idref" href="liblayers.simrel.MemOpv.html#ofs2"><span class="id" title="variable">ofs2</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">∨</span></a> <a class="idref" href="liblayers.simrel.MemOpv.html#ofs2"><span class="id" title="variable">ofs2</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.ZArith.BinInt.html#a3448b794f7a26d611ad36492b5d640b"><span class="id" title="notation">+</span></a> <a class="idref" href="liblayers.simrel.MemOpv.html#sz"><span class="id" title="variable">sz</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.ZArith.BinInt.html#208bafb0e148fe7fb7dcd812c227f4ee"><span class="id" title="notation">≤</span></a> <a class="idref" href="liblayers.simrel.MemOpv.html#ofs1"><span class="id" title="variable">ofs1</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d82a7d96d3659d805ffe732283716822"><span class="id" title="notation">)</span></a>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <a name="Mem.disjoint_or_equalv"><span class="id" title="definition">disjoint_or_equalv</span></a> <span class="id" title="var">sz</span> <span class="id" title="var">m</span> <span class="id" title="var">v1</span> <span class="id" title="var">v2</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="liblayers.simrel.MemOpv.html#v1"><span class="id" title="variable">v1</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="compcert.common.Values.html#Vptr"><span class="id" title="constructor">Vptr</span></a> <span class="id" title="var">b1</span> <span class="id" title="var">o1</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="liblayers.simrel.MemOpv.html#v2"><span class="id" title="variable">v2</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="compcert.common.Values.html#Vptr"><span class="id" title="constructor">Vptr</span></a> <span class="id" title="var">b2</span> <span class="id" title="var">o2</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="liblayers.simrel.MemOpv.html#Mem.disjoint_or_equal"><span class="id" title="definition">disjoint_or_equal</span></a> <a class="idref" href="liblayers.simrel.MemOpv.html#sz"><span class="id" title="variable">sz</span></a> <a class="idref" href="liblayers.simrel.MemOpv.html#m"><span class="id" title="variable">m</span></a> <span class="id" title="var">b1</span> (<a class="idref" href="compcert.lib.Integers.html#Ptrofs.unsigned"><span class="id" title="definition">Ptrofs.unsigned</span></a> <span class="id" title="var">o1</span>) <span class="id" title="var">b2</span> (<a class="idref" href="compcert.lib.Integers.html#Ptrofs.unsigned"><span class="id" title="definition">Ptrofs.unsigned</span></a> <span class="id" title="var">o2</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">_</span> ⇒ <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#False"><span class="id" title="inductive">False</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">_</span> ⇒ <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#False"><span class="id" title="inductive">False</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <a name="Mem.aligned_area"><span class="id" title="definition">aligned_area</span></a> <span class="id" title="var">al</span> <span class="id" title="var">sz</span> <span class="id" title="var">m</span> <span class="id" title="var">b</span> <span class="id" title="var">o</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d82a7d96d3659d805ffe732283716822"><span class="id" title="notation">(</span></a><a class="idref" href="liblayers.simrel.MemOpv.html#al"><span class="id" title="variable">al</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> 1 <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">∨</span></a> <a class="idref" href="liblayers.simrel.MemOpv.html#al"><span class="id" title="variable">al</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> 2 <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">∨</span></a> <a class="idref" href="liblayers.simrel.MemOpv.html#al"><span class="id" title="variable">al</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> 4 <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#7a45dffb109c3069e5c675be68643e60"><span class="id" title="notation">∨</span></a> <a class="idref" href="liblayers.simrel.MemOpv.html#al"><span class="id" title="variable">al</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> 8<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d82a7d96d3659d805ffe732283716822"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d82a7d96d3659d805ffe732283716822"><span class="id" title="notation">∧</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d82a7d96d3659d805ffe732283716822"><span class="id" title="notation">(</span></a><a class="idref" href="liblayers.simrel.MemOpv.html#sz"><span class="id" title="variable">sz</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.ZArith.BinInt.html#a1c07c706e79df7cc9eee5b1e369014a"><span class="id" title="notation">&gt;</span></a> 0 <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.ZArith.BinInt.html#22aee23095fa75a48e17ac5311892ed3"><span class="id" title="notation">(</span></a><a class="idref" href="liblayers.simrel.MemOpv.html#al"><span class="id" title="variable">al</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.ZArith.BinInt.html#22aee23095fa75a48e17ac5311892ed3"><span class="id" title="notation">|</span></a> <a class="idref" href="liblayers.simrel.MemOpv.html#sz"><span class="id" title="variable">sz</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.ZArith.BinInt.html#22aee23095fa75a48e17ac5311892ed3"><span class="id" title="notation">)</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d82a7d96d3659d805ffe732283716822"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d82a7d96d3659d805ffe732283716822"><span class="id" title="notation">∧</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="compcert.common.Memtype.html#Mem.range_perm"><span class="id" title="method">Mem.range_perm</span></a> <a class="idref" href="liblayers.simrel.MemOpv.html#m"><span class="id" title="variable">m</span></a> <a class="idref" href="liblayers.simrel.MemOpv.html#b"><span class="id" title="variable">b</span></a> <a class="idref" href="liblayers.simrel.MemOpv.html#o"><span class="id" title="variable">o</span></a> (<a class="idref" href="liblayers.simrel.MemOpv.html#o"><span class="id" title="variable">o</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.ZArith.BinInt.html#a3448b794f7a26d611ad36492b5d640b"><span class="id" title="notation">+</span></a> <a class="idref" href="liblayers.simrel.MemOpv.html#sz"><span class="id" title="variable">sz</span></a>) <a class="idref" href="compcert.common.Memtype.html#Cur"><span class="id" title="constructor">Cur</span></a> <a class="idref" href="compcert.common.Memtype.html#Nonempty"><span class="id" title="constructor">Nonempty</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d82a7d96d3659d805ffe732283716822"><span class="id" title="notation">∧</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d82a7d96d3659d805ffe732283716822"><span class="id" title="notation">(</span></a><a class="idref" href="liblayers.simrel.MemOpv.html#sz"><span class="id" title="variable">sz</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.ZArith.BinInt.html#a1c07c706e79df7cc9eee5b1e369014a"><span class="id" title="notation">&gt;</span></a> 0 <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.ZArith.BinInt.html#22aee23095fa75a48e17ac5311892ed3"><span class="id" title="notation">(</span></a><a class="idref" href="liblayers.simrel.MemOpv.html#al"><span class="id" title="variable">al</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.ZArith.BinInt.html#22aee23095fa75a48e17ac5311892ed3"><span class="id" title="notation">|</span></a> <a class="idref" href="liblayers.simrel.MemOpv.html#o"><span class="id" title="variable">o</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.ZArith.BinInt.html#22aee23095fa75a48e17ac5311892ed3"><span class="id" title="notation">)</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d82a7d96d3659d805ffe732283716822"><span class="id" title="notation">)</span></a>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <a name="Mem.aligned_areav"><span class="id" title="definition">aligned_areav</span></a> <span class="id" title="var">al</span> <span class="id" title="var">sz</span> <span class="id" title="var">m</span> <span class="id" title="var">v</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="liblayers.simrel.MemOpv.html#v"><span class="id" title="variable">v</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="compcert.common.Values.html#Vptr"><span class="id" title="constructor">Vptr</span></a> <span class="id" title="var">b</span> <span class="id" title="var">o</span> ⇒ <a class="idref" href="liblayers.simrel.MemOpv.html#Mem.aligned_area"><span class="id" title="definition">aligned_area</span></a> <a class="idref" href="liblayers.simrel.MemOpv.html#al"><span class="id" title="variable">al</span></a> <a class="idref" href="liblayers.simrel.MemOpv.html#sz"><span class="id" title="variable">sz</span></a> <a class="idref" href="liblayers.simrel.MemOpv.html#m"><span class="id" title="variable">m</span></a> <span class="id" title="var">b</span> (<a class="idref" href="compcert.lib.Integers.html#Ptrofs.unsigned"><span class="id" title="definition">Ptrofs.unsigned</span></a> <span class="id" title="var">o</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">_</span> ⇒ <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#False"><span class="id" title="inductive">False</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <a name="Mem.freev"><span class="id" title="definition">freev</span></a> <span class="id" title="var">m</span> <span class="id" title="var">v</span> <span class="id" title="var">sz</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="liblayers.simrel.MemOpv.html#v"><span class="id" title="variable">v</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="compcert.common.Values.html#Vptr"><span class="id" title="constructor">Vptr</span></a> <span class="id" title="var">b</span> <span class="id" title="var">o</span> ⇒ <a class="idref" href="compcert.common.Memtype.html#Mem.free"><span class="id" title="method">free</span></a> <a class="idref" href="liblayers.simrel.MemOpv.html#m"><span class="id" title="variable">m</span></a> <span class="id" title="var">b</span> (<a class="idref" href="compcert.lib.Integers.html#Ptrofs.unsigned"><span class="id" title="definition">Ptrofs.unsigned</span></a> <span class="id" title="var">o</span>) (<a class="idref" href="compcert.lib.Integers.html#Ptrofs.unsigned"><span class="id" title="definition">Ptrofs.unsigned</span></a> <span class="id" title="var">o</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.ZArith.BinInt.html#a3448b794f7a26d611ad36492b5d640b"><span class="id" title="notation">+</span></a> <a class="idref" href="liblayers.simrel.MemOpv.html#sz"><span class="id" title="variable">sz</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">_</span> ⇒ <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#None"><span class="id" title="constructor">None</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <a name="Mem.valid_pointerv"><span class="id" title="definition">valid_pointerv</span></a> <span class="id" title="var">m</span> <span class="id" title="var">v</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="liblayers.simrel.MemOpv.html#v"><span class="id" title="variable">v</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="compcert.common.Values.html#Vptr"><span class="id" title="constructor">Vptr</span></a> <span class="id" title="var">b</span> <span class="id" title="var">o</span> ⇒ <a class="idref" href="compcert.common.Memtype.html#Mem.valid_pointer"><span class="id" title="method">Mem.valid_pointer</span></a> <a class="idref" href="liblayers.simrel.MemOpv.html#m"><span class="id" title="variable">m</span></a> <span class="id" title="var">b</span> (<a class="idref" href="compcert.lib.Integers.html#Ptrofs.unsigned"><span class="id" title="definition">Ptrofs.unsigned</span></a> <span class="id" title="var">o</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">_</span> ⇒ <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#false"><span class="id" title="constructor">false</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <a name="Mem.weak_valid_pointerv"><span class="id" title="definition">weak_valid_pointerv</span></a> <span class="id" title="var">m</span> <span class="id" title="var">v</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="liblayers.simrel.MemOpv.html#v"><span class="id" title="variable">v</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="compcert.common.Values.html#Vptr"><span class="id" title="constructor">Vptr</span></a> <span class="id" title="var">b</span> <span class="id" title="var">o</span> ⇒ <a class="idref" href="compcert.common.Memtype.html#Mem.weak_valid_pointer"><span class="id" title="definition">Mem.weak_valid_pointer</span></a> <a class="idref" href="liblayers.simrel.MemOpv.html#m"><span class="id" title="variable">m</span></a> <span class="id" title="var">b</span> (<a class="idref" href="compcert.lib.Integers.html#Ptrofs.unsigned"><span class="id" title="definition">Ptrofs.unsigned</span></a> <span class="id" title="var">o</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">_</span> ⇒ <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#false"><span class="id" title="constructor">false</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">End</span> <a class="idref" href="liblayers.simrel.MemOpv.html#Mem.WITHMEMORYMODELOPS"><span class="id" title="section">WITHMEMORYMODELOPS</span></a>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Section</span> <a name="Mem.WITHMEMORYMODELX"><span class="id" title="section">WITHMEMORYMODELX</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Context</span> `{<span class="id" title="var">memory_model_x</span>: <a class="idref" href="compcertx.common.MemoryX.html#Mem.MemoryModelX"><span class="id" title="class">MemoryModelX</span></a>}.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Lemma</span> <a name="Mem.storebytes_nil"><span class="id" title="lemma">storebytes_nil</span></a> <span class="id" title="var">m</span> <span class="id" title="var">b</span> <span class="id" title="var">o</span> <span class="id" title="var">l</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#length"><span class="id" title="definition">length</span></a> <a class="idref" href="liblayers.simrel.MemOpv.html#l"><span class="id" title="variable">l</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> 0%<span class="id" title="var">nat</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="compcert.common.Memtype.html#Mem.storebytes"><span class="id" title="method">Mem.storebytes</span></a> <a class="idref" href="liblayers.simrel.MemOpv.html#m"><span class="id" title="variable">m</span></a> <a class="idref" href="liblayers.simrel.MemOpv.html#b"><span class="id" title="variable">b</span></a> <a class="idref" href="liblayers.simrel.MemOpv.html#o"><span class="id" title="variable">o</span></a> <a class="idref" href="liblayers.simrel.MemOpv.html#l"><span class="id" title="variable">l</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#Some"><span class="id" title="constructor">Some</span></a> <a class="idref" href="liblayers.simrel.MemOpv.html#m"><span class="id" title="variable">m</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">l</span>; <span class="id" title="tactic">try</span> <span class="id" title="tactic">discriminate</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">edestruct</span> (<a class="idref" href="compcert.common.Memtype.html#Mem.range_perm_storebytes"><span class="id" title="lemma">Mem.range_perm_storebytes</span></a> <span class="id" title="var">m</span> <span class="id" title="var">b</span> <span class="id" title="var">o</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#nil"><span class="id" title="constructor">nil</span></a>) <span class="id" title="keyword">as</span> [? <span class="id" title="var">MEM</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">red</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">omega</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">generalize</span> (<a class="idref" href="compcertx.common.MemoryX.html#Mem.storebytes_empty"><span class="id" title="method">storebytes_empty</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">MEM</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">congruence</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Qed</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">End</span> <a class="idref" href="liblayers.simrel.MemOpv.html#Mem.WITHMEMORYMODELX"><span class="id" title="section">WITHMEMORYMODELX</span></a>.<br/>
<span class="id" title="keyword">End</span> <a class="idref" href="liblayers.simrel.MemOpv.html#Mem"><span class="id" title="module">Mem</span></a>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab498"></a><h1 class="section">Monotonicity properties</h1>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Section</span> <a name="SIMREL"><span class="id" title="section">SIMREL</span></a>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Context</span> `{<span class="id" title="var">HR</span>: <a class="idref" href="liblayers.simrel.SimrelDefinition.html#SimulationRelation"><span class="id" title="class">SimulationRelation</span></a>}.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Local Opaque</span> <a class="idref" href="liblayers.simrel.MemWithData.html#mwd_ops"><span class="id" title="instance">mwd_ops</span></a>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Global Instance</span> <a name="simrel_permv"><span class="id" title="instance">simrel_permv</span></a> <span class="id" title="var">p</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="coqrel.RelDefinitions.html#Monotonic"><span class="id" title="abbreviation">Monotonic</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="liblayers.simrel.MemOpv.html#permv"><span class="id" title="definition">Mem.permv</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="liblayers.simrel.SimrelDefinition.html#match_mem"><span class="id" title="projection">match_mem</span></a> <a class="idref" href="liblayers.simrel.MemOpv.html#SIMREL.R"><span class="id" title="variable">R</span></a> <a class="idref" href="liblayers.simrel.MemOpv.html#p"><span class="id" title="variable">p</span></a> <a class="idref" href="coqrel.RelDefinitions.html#d5d0ad6beccd25d5224442d64ed307d5"><span class="id" title="notation">++&gt;</span></a> <a class="idref" href="liblayers.simrel.SimrelDefinition.html#match_val"><span class="id" title="inductive">match_val</span></a> <a class="idref" href="liblayers.simrel.MemOpv.html#SIMREL.R"><span class="id" title="variable">R</span></a> <a class="idref" href="liblayers.simrel.MemOpv.html#p"><span class="id" title="variable">p</span></a> <a class="idref" href="coqrel.RelDefinitions.html#d5d0ad6beccd25d5224442d64ed307d5"><span class="id" title="notation">++&gt;</span></a> <a class="idref" href="coqrel.Relators.html#da8817e538e6bc1d3d2ad0cfb530ab9c"><span class="id" title="notation">-</span></a> <a class="idref" href="coqrel.Relators.html#da8817e538e6bc1d3d2ad0cfb530ab9c"><span class="id" title="notation">==&gt;</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Program.Basics.html#impl"><span class="id" title="definition">impl</span></a>).<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">repeat</span> <span class="id" title="tactic">red</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <a class="idref" href="liblayers.simrel.MemOpv.html#permv"><span class="id" title="definition">Mem.permv</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> <span class="id" title="var">H</span> <span class="id" title="var">x0</span> <span class="id" title="var">y0</span> <span class="id" title="var">H0</span> <span class="id" title="var">a</span> <span class="id" title="var">H1</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">inversion</span> <span class="id" title="var">H0</span>; <span class="id" title="tactic">subst</span>; <span class="id" title="tactic">try</span> <span class="id" title="tactic">tauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">generalize</span> <span class="id" title="var">H1</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">repeat</span> <span class="id" title="var">rstep</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">eapply</span> <a class="idref" href="liblayers.simrel.SimrelDefinition.html#match_ptrbits_ptr"><span class="id" title="lemma">match_ptrbits_ptr</span></a>; <span class="id" title="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Qed</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Global Instance</span> <a name="simrel_loadbytesv"><span class="id" title="instance">simrel_loadbytesv</span></a> <span class="id" title="var">p</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="coqrel.RelDefinitions.html#Monotonic"><span class="id" title="abbreviation">Monotonic</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="liblayers.simrel.MemOpv.html#loadbytesv"><span class="id" title="definition">Mem.loadbytesv</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="liblayers.simrel.SimrelDefinition.html#match_mem"><span class="id" title="projection">match_mem</span></a> <a class="idref" href="liblayers.simrel.MemOpv.html#SIMREL.R"><span class="id" title="variable">R</span></a> <a class="idref" href="liblayers.simrel.MemOpv.html#p"><span class="id" title="variable">p</span></a> <a class="idref" href="coqrel.RelDefinitions.html#d5d0ad6beccd25d5224442d64ed307d5"><span class="id" title="notation">++&gt;</span></a> <a class="idref" href="liblayers.simrel.SimrelDefinition.html#match_val"><span class="id" title="inductive">match_val</span></a> <a class="idref" href="liblayers.simrel.MemOpv.html#SIMREL.R"><span class="id" title="variable">R</span></a> <a class="idref" href="liblayers.simrel.MemOpv.html#p"><span class="id" title="variable">p</span></a> <a class="idref" href="coqrel.RelDefinitions.html#d5d0ad6beccd25d5224442d64ed307d5"><span class="id" title="notation">++&gt;</span></a> <a class="idref" href="coqrel.Relators.html#da8817e538e6bc1d3d2ad0cfb530ab9c"><span class="id" title="notation">-</span></a> <a class="idref" href="coqrel.Relators.html#da8817e538e6bc1d3d2ad0cfb530ab9c"><span class="id" title="notation">==&gt;</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="liblayers.logic.OptionOrders.html#option_le"><span class="id" title="inductive">option_le</span></a> (<a class="idref" href="coqrel.Relators.html#list_rel"><span class="id" title="inductive">list_rel</span></a> (<a class="idref" href="liblayers.simrel.SimrelDefinition.html#match_memval"><span class="id" title="inductive">match_memval</span></a> <a class="idref" href="liblayers.simrel.MemOpv.html#SIMREL.R"><span class="id" title="variable">R</span></a> <a class="idref" href="liblayers.simrel.MemOpv.html#p"><span class="id" title="variable">p</span></a>))).<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">repeat</span> <span class="id" title="tactic">red</span>. <span class="id" title="tactic">unfold</span> <a class="idref" href="liblayers.simrel.MemOpv.html#loadbytesv"><span class="id" title="definition">Mem.loadbytesv</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> <span class="id" title="var">H</span> <span class="id" title="var">x0</span> <span class="id" title="var">y0</span> <span class="id" title="var">H0</span> <span class="id" title="var">a</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">inversion</span> <span class="id" title="var">H0</span>; <span class="id" title="tactic">subst</span>; <span class="id" title="tactic">try</span> <span class="id" title="var">now</span> <span class="id" title="tactic">constructor</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> (<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.ZArith.ZArith_dec.html#Z_le_dec"><span class="id" title="definition">Z_le_dec</span></a> <span class="id" title="var">a</span> 0) <span class="id" title="keyword">as</span> [ <span class="id" title="var">LE</span> | ] .<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">repeat</span> <span class="id" title="var">erewrite</span> <a class="idref" href="compcert.common.Memtype.html#Mem.loadbytes_empty"><span class="id" title="method">Mem.loadbytes_empty</span></a> <span class="id" title="tactic">by</span> <span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <a class="idref" href="liblayers.logic.OptionOrders.html#option_le_some_def"><span class="id" title="constructor">option_le_some_def</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">repeat</span> <span class="id" title="tactic">constructor</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> (<a class="idref" href="compcert.common.Memtype.html#Mem.loadbytes"><span class="id" title="method">Mem.loadbytes</span></a> <span class="id" title="var">x</span> <span class="id" title="var">_</span> (<a class="idref" href="compcert.lib.Integers.html#Ptrofs.unsigned"><span class="id" title="definition">Ptrofs.unsigned</span></a> <span class="id" title="var">_</span>) <span class="id" title="var">a</span>) <span class="id" title="var">eqn</span>:<span class="id" title="var">EQ</span>; <span class="id" title="tactic">try</span> <span class="id" title="var">now</span> <span class="id" title="tactic">constructor</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> &lt;- <span class="id" title="var">EQ</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">repeat</span> <span class="id" title="var">rstep</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">eapply</span> <a class="idref" href="liblayers.simrel.SimrelDefinition.html#match_ptrbits_ptr"><span class="id" title="lemma">match_ptrbits_ptr</span></a>; <span class="id" title="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">eapply</span> <a class="idref" href="compcert.common.Memtype.html#Mem.loadbytes_range_perm"><span class="id" title="method">Mem.loadbytes_range_perm</span></a>; <span class="id" title="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">omega</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Qed</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Global Instance</span> <a name="simrel_storebytesv"><span class="id" title="instance">simrel_storebytesv</span></a> <span class="id" title="var">p</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="coqrel.RelDefinitions.html#Monotonic"><span class="id" title="abbreviation">Monotonic</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="liblayers.simrel.MemOpv.html#storebytesv"><span class="id" title="definition">Mem.storebytesv</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="liblayers.simrel.SimrelDefinition.html#match_mem"><span class="id" title="projection">match_mem</span></a> <a class="idref" href="liblayers.simrel.MemOpv.html#SIMREL.R"><span class="id" title="variable">R</span></a> <a class="idref" href="liblayers.simrel.MemOpv.html#p"><span class="id" title="variable">p</span></a> <a class="idref" href="coqrel.RelDefinitions.html#d5d0ad6beccd25d5224442d64ed307d5"><span class="id" title="notation">++&gt;</span></a> <a class="idref" href="liblayers.simrel.SimrelDefinition.html#match_val"><span class="id" title="inductive">match_val</span></a> <a class="idref" href="liblayers.simrel.MemOpv.html#SIMREL.R"><span class="id" title="variable">R</span></a> <a class="idref" href="liblayers.simrel.MemOpv.html#p"><span class="id" title="variable">p</span></a> <a class="idref" href="coqrel.RelDefinitions.html#d5d0ad6beccd25d5224442d64ed307d5"><span class="id" title="notation">++&gt;</span></a> <a class="idref" href="coqrel.Relators.html#list_rel"><span class="id" title="inductive">list_rel</span></a> (<a class="idref" href="liblayers.simrel.SimrelDefinition.html#match_memval"><span class="id" title="inductive">match_memval</span></a> <a class="idref" href="liblayers.simrel.MemOpv.html#SIMREL.R"><span class="id" title="variable">R</span></a> <a class="idref" href="liblayers.simrel.MemOpv.html#p"><span class="id" title="variable">p</span></a>) <a class="idref" href="coqrel.RelDefinitions.html#d5d0ad6beccd25d5224442d64ed307d5"><span class="id" title="notation">++&gt;</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="liblayers.logic.OptionOrders.html#option_le"><span class="id" title="inductive">option_le</span></a> (<a class="idref" href="liblayers.simrel.SimrelDefinition.html#238e5b84009b7e00668800f6e2df3b39"><span class="id" title="notation">incr</span></a> <a class="idref" href="liblayers.simrel.MemOpv.html#p"><span class="id" title="variable">p</span></a> <a class="idref" href="liblayers.simrel.SimrelDefinition.html#238e5b84009b7e00668800f6e2df3b39"><span class="id" title="notation">(</span></a><a class="idref" href="liblayers.simrel.SimrelDefinition.html#match_mem"><span class="id" title="projection">match_mem</span></a> <a class="idref" href="liblayers.simrel.MemOpv.html#SIMREL.R"><span class="id" title="variable">R</span></a> <a class="idref" href="liblayers.simrel.MemOpv.html#p"><span class="id" title="variable">p</span></a><a class="idref" href="liblayers.simrel.SimrelDefinition.html#238e5b84009b7e00668800f6e2df3b39"><span class="id" title="notation">)</span></a>)).<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> <span class="id" title="var">H</span> <span class="id" title="var">x0</span> <span class="id" title="var">y0</span> <span class="id" title="var">H0</span> <span class="id" title="var">x1</span> <span class="id" title="var">y1</span> <span class="id" title="var">H1</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">inversion</span> <span class="id" title="var">H0</span>; <span class="id" title="tactic">subst</span>; <span class="id" title="tactic">try</span> <span class="id" title="var">now</span> <span class="id" title="var">solve_monotonic</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">inversion</span> <span class="id" title="var">H1</span>; <span class="id" title="tactic">subst</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">repeat</span> <span class="id" title="tactic">rewrite</span> <a class="idref" href="liblayers.simrel.MemOpv.html#storebytes_nil"><span class="id" title="lemma">Mem.storebytes_nil</span></a> <span class="id" title="tactic">by</span> <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">solve_monotonic</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> (<a class="idref" href="compcert.common.Memtype.html#Mem.storebytes"><span class="id" title="method">Mem.storebytes</span></a> <span class="id" title="var">x</span> <span class="id" title="var">_</span> (<a class="idref" href="compcert.lib.Integers.html#Ptrofs.unsigned"><span class="id" title="definition">Ptrofs.unsigned</span></a> <span class="id" title="var">_</span>) <span class="id" title="var">_</span>) <span class="id" title="var">eqn</span>:<span class="id" title="var">EQ</span>; <span class="id" title="tactic">try</span> <span class="id" title="var">now</span> <span class="id" title="var">solve_monotonic</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> &lt;- <span class="id" title="var">EQ</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">repeat</span> <span class="id" title="var">rstep</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">eapply</span> <a class="idref" href="liblayers.simrel.SimrelDefinition.html#match_ptrbits_ptr"><span class="id" title="lemma">match_ptrbits_ptr</span></a>; <span class="id" title="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">eapply</span> <a class="idref" href="compcert.common.Memtype.html#Mem.storebytes_range_perm"><span class="id" title="method">Mem.storebytes_range_perm</span></a>; <span class="id" title="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span> <span class="id" title="var">length</span>. <span class="id" title="tactic">rewrite</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.ZArith.Znat.html#Nat2Z.inj_succ"><span class="id" title="lemma">Nat2Z.inj_succ</span></a>. <span class="id" title="tactic">omega</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Qed</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Global Instance</span> <a name="simrel_range_perm"><span class="id" title="instance">simrel_range_perm</span></a> <span class="id" title="var">p</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="coqrel.RelDefinitions.html#Monotonic"><span class="id" title="abbreviation">Monotonic</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="compcert.common.Memtype.html#Mem.range_perm"><span class="id" title="method">Mem.range_perm</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="liblayers.simrel.SimrelDefinition.html#match_mem"><span class="id" title="projection">match_mem</span></a> <a class="idref" href="liblayers.simrel.MemOpv.html#SIMREL.R"><span class="id" title="variable">R</span></a> <a class="idref" href="liblayers.simrel.MemOpv.html#p"><span class="id" title="variable">p</span></a> <a class="idref" href="coqrel.RelDefinitions.html#d5d0ad6beccd25d5224442d64ed307d5"><span class="id" title="notation">++&gt;</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="coqrel.RelOperators.html#rel_curry"><span class="id" title="definition">rel_curry</span></a> (<a class="idref" href="coqrel.RelOperators.html#rel_curry"><span class="id" title="definition">rel_curry</span></a> (<a class="idref" href="liblayers.simrel.SimrelDefinition.html#match_ptrrange"><span class="id" title="inductive">match_ptrrange</span></a> <a class="idref" href="liblayers.simrel.MemOpv.html#SIMREL.R"><span class="id" title="variable">R</span></a> <a class="idref" href="liblayers.simrel.MemOpv.html#p"><span class="id" title="variable">p</span></a> <a class="idref" href="coqrel.RelDefinitions.html#d5d0ad6beccd25d5224442d64ed307d5"><span class="id" title="notation">++&gt;</span></a> <a class="idref" href="coqrel.Relators.html#da8817e538e6bc1d3d2ad0cfb530ab9c"><span class="id" title="notation">-</span></a> <a class="idref" href="coqrel.Relators.html#da8817e538e6bc1d3d2ad0cfb530ab9c"><span class="id" title="notation">==&gt;</span></a> <a class="idref" href="coqrel.Relators.html#da8817e538e6bc1d3d2ad0cfb530ab9c"><span class="id" title="notation">-</span></a> <a class="idref" href="coqrel.Relators.html#da8817e538e6bc1d3d2ad0cfb530ab9c"><span class="id" title="notation">==&gt;</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Program.Basics.html#impl"><span class="id" title="definition">impl</span></a>))).<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">repeat</span> <span class="id" title="tactic">red</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> [[<span class="id" title="var">b0</span> <span class="id" title="var">lo0</span>] <span class="id" title="var">hi0</span>] [[<span class="id" title="var">b1</span> <span class="id" title="var">lo1</span>] <span class="id" title="var">hi1</span>] <span class="id" title="var">MATCH</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">a</span> <span class="id" title="var">a0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">inversion</span> <span class="id" title="var">MATCH</span>; <span class="id" title="tactic">subst</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <a class="idref" href="compcert.common.Memtype.html#Mem.range_perm"><span class="id" title="method">Mem.range_perm</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">H0</span> <span class="id" title="var">ofs</span> <span class="id" title="var">H2</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">inversion</span> <span class="id" title="var">H1</span>; <span class="id" title="tactic">subst</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="keyword">goal</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">_</span>: <a class="idref" href="liblayers.simrel.SimrelDefinition.html#simrel_meminj"><span class="id" title="projection">simrel_meminj</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#Some"><span class="id" title="constructor">Some</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">(</span></a><span class="id" title="var">_</span><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">,</span></a> ?<span class="id" title="var">d</span><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">)</span></a> |- <span class="id" title="var">_</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">replace</span> <span class="id" title="var">ofs</span> <span class="id" title="keyword">with</span> (<span class="id" title="var">ofs</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.ZArith.BinInt.html#239a40728d107295b3cb2c790f57f9e9"><span class="id" title="notation">-</span></a> <span class="id" title="var">d</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.ZArith.BinInt.html#a3448b794f7a26d611ad36492b5d640b"><span class="id" title="notation">+</span></a> <span class="id" title="var">d</span>)%<span class="id" title="var">Z</span> <span class="id" title="tactic">by</span> <span class="id" title="tactic">omega</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">specialize</span> (<span class="id" title="var">H0</span> (<span class="id" title="var">ofs</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.ZArith.BinInt.html#239a40728d107295b3cb2c790f57f9e9"><span class="id" title="notation">-</span></a> <span class="id" title="var">d</span>)%<span class="id" title="var">Z</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">type</span> <span class="id" title="var">of</span> <span class="id" title="var">H0</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;?<span class="id" title="var">Z</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <span class="id" title="var">_</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">assert</span> <span class="id" title="var">Z</span> <span class="id" title="keyword">as</span> <span class="id" title="var">U</span> <span class="id" title="tactic">by</span> <span class="id" title="tactic">omega</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">generalize</span> (<span class="id" title="var">H0</span> <span class="id" title="var">U</span>);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">clear</span> <span class="id" title="var">H0</span> <span class="id" title="var">U</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">solve_monotonic</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">constructor</span>; <span class="id" title="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Qed</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Global Instance</span> <a name="simrel_range_permv"><span class="id" title="instance">simrel_range_permv</span></a> <span class="id" title="var">p</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="coqrel.RelDefinitions.html#Monotonic"><span class="id" title="abbreviation">Monotonic</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="liblayers.simrel.MemOpv.html#range_permv"><span class="id" title="definition">Mem.range_permv</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="liblayers.simrel.SimrelDefinition.html#match_mem"><span class="id" title="projection">match_mem</span></a> <a class="idref" href="liblayers.simrel.MemOpv.html#SIMREL.R"><span class="id" title="variable">R</span></a> <a class="idref" href="liblayers.simrel.MemOpv.html#p"><span class="id" title="variable">p</span></a> <a class="idref" href="coqrel.RelDefinitions.html#d5d0ad6beccd25d5224442d64ed307d5"><span class="id" title="notation">++&gt;</span></a> <a class="idref" href="liblayers.simrel.SimrelDefinition.html#match_val"><span class="id" title="inductive">match_val</span></a> <a class="idref" href="liblayers.simrel.MemOpv.html#SIMREL.R"><span class="id" title="variable">R</span></a> <a class="idref" href="liblayers.simrel.MemOpv.html#p"><span class="id" title="variable">p</span></a> <a class="idref" href="coqrel.RelDefinitions.html#d5d0ad6beccd25d5224442d64ed307d5"><span class="id" title="notation">++&gt;</span></a> <a class="idref" href="coqrel.Relators.html#da8817e538e6bc1d3d2ad0cfb530ab9c"><span class="id" title="notation">-</span></a> <a class="idref" href="coqrel.Relators.html#da8817e538e6bc1d3d2ad0cfb530ab9c"><span class="id" title="notation">==&gt;</span></a> <a class="idref" href="coqrel.Relators.html#da8817e538e6bc1d3d2ad0cfb530ab9c"><span class="id" title="notation">-</span></a> <a class="idref" href="coqrel.Relators.html#da8817e538e6bc1d3d2ad0cfb530ab9c"><span class="id" title="notation">==&gt;</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Program.Basics.html#impl"><span class="id" title="definition">impl</span></a>).<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> <span class="id" title="var">H</span> <span class="id" title="var">x0</span> <span class="id" title="var">y0</span> <span class="id" title="var">H0</span> <span class="id" title="var">a</span> <span class="id" title="var">a0</span> <span class="id" title="var">H1</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">inversion</span> <span class="id" title="var">H0</span>; <span class="id" title="tactic">subst</span>; <span class="id" title="tactic">try</span> <span class="id" title="var">contradiction</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> (<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.ZArith.ZArith_dec.html#Z_le_dec"><span class="id" title="definition">Z_le_dec</span></a> <span class="id" title="var">a</span> 0).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">red</span>. <span class="id" title="tactic">intros</span> <span class="id" title="var">ofs</span> <span class="id" title="var">H3</span>. <span class="id" title="tactic">omega</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">generalize</span> <span class="id" title="var">H1</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">eapply</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">q</span> <span class="id" title="var">K</span> ⇒ <a class="idref" href="liblayers.simrel.MemOpv.html#simrel_range_perm"><span class="id" title="instance">simrel_range_perm</span></a> <a class="idref" href="liblayers.simrel.MemOpv.html#q"><span class="id" title="variable">q</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <a class="idref" href="liblayers.simrel.MemOpv.html#K"><span class="id" title="variable">K</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">((</span></a><span class="id" title="var">_</span><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">,</span></a> <span class="id" title="var">_</span><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">),</span></a> <span class="id" title="var">_</span><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">((</span></a><span class="id" title="var">_</span><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">,</span></a> <span class="id" title="var">_</span><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">),</span></a> <span class="id" title="var">_</span><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">)</span></a>); <span class="id" title="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">constructor</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">eapply</span> <a class="idref" href="liblayers.simrel.SimrelDefinition.html#match_ptrbits_ptr"><span class="id" title="lemma">match_ptrbits_ptr</span></a>; <span class="id" title="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">eapply</span> <span class="id" title="var">H1</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">omega</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Qed</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Global Instance</span> <a name="simrel_disjoint_or_equal"><span class="id" title="instance">simrel_disjoint_or_equal</span></a> <span class="id" title="var">p</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="coqrel.RelDefinitions.html#Monotonic"><span class="id" title="abbreviation">Monotonic</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="liblayers.simrel.MemOpv.html#disjoint_or_equal"><span class="id" title="definition">Mem.disjoint_or_equal</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="coqrel.Relators.html#da8817e538e6bc1d3d2ad0cfb530ab9c"><span class="id" title="notation">-</span></a> <a class="idref" href="coqrel.Relators.html#da8817e538e6bc1d3d2ad0cfb530ab9c"><span class="id" title="notation">==&gt;</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="liblayers.simrel.SimrelDefinition.html#match_mem"><span class="id" title="projection">match_mem</span></a> <a class="idref" href="liblayers.simrel.MemOpv.html#SIMREL.R"><span class="id" title="variable">R</span></a> <a class="idref" href="liblayers.simrel.MemOpv.html#p"><span class="id" title="variable">p</span></a> <a class="idref" href="coqrel.RelDefinitions.html#d5d0ad6beccd25d5224442d64ed307d5"><span class="id" title="notation">++&gt;</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="coqrel.RelOperators.html#rel_curry"><span class="id" title="definition">rel_curry</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="liblayers.simrel.SimrelDefinition.html#match_ptr"><span class="id" title="inductive">match_ptr</span></a> <a class="idref" href="liblayers.simrel.MemOpv.html#SIMREL.R"><span class="id" title="variable">R</span></a> <a class="idref" href="liblayers.simrel.MemOpv.html#p"><span class="id" title="variable">p</span></a> <a class="idref" href="coqrel.RelDefinitions.html#d5d0ad6beccd25d5224442d64ed307d5"><span class="id" title="notation">++&gt;</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="coqrel.RelOperators.html#rel_curry"><span class="id" title="definition">rel_curry</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="liblayers.simrel.SimrelDefinition.html#match_ptr"><span class="id" title="inductive">match_ptr</span></a> <a class="idref" href="liblayers.simrel.MemOpv.html#SIMREL.R"><span class="id" title="variable">R</span></a> <a class="idref" href="liblayers.simrel.MemOpv.html#p"><span class="id" title="variable">p</span></a> <a class="idref" href="coqrel.RelDefinitions.html#d5d0ad6beccd25d5224442d64ed307d5"><span class="id" title="notation">++&gt;</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Program.Basics.html#impl"><span class="id" title="definition">impl</span></a>))).<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">repeat</span> <span class="id" title="tactic">red</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">a</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> <span class="id" title="var">H</span> [<span class="id" title="var">b0</span> <span class="id" title="var">o0</span>] [<span class="id" title="var">b0'</span> <span class="id" title="var">o0'</span>] <span class="id" title="var">H0</span> [<span class="id" title="var">b1</span> <span class="id" title="var">o1</span>] [<span class="id" title="var">b1'</span> <span class="id" title="var">o1'</span>] <span class="id" title="var">H1</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <a class="idref" href="liblayers.simrel.MemOpv.html#disjoint_or_equal"><span class="id" title="definition">Mem.disjoint_or_equal</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> (<span class="id" title="var">NONNEG</span> &amp; <span class="id" title="var">PERM0</span> &amp; <span class="id" title="var">PERM1</span> &amp; <span class="id" title="var">DISJ_OR_EQ</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">split</span>; <span class="id" title="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">split</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">revert</span> <span class="id" title="var">PERM0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">eapply</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">q</span> <span class="id" title="var">K</span> ⇒ <a class="idref" href="liblayers.simrel.MemOpv.html#simrel_range_perm"><span class="id" title="instance">simrel_range_perm</span></a> <a class="idref" href="liblayers.simrel.MemOpv.html#q"><span class="id" title="variable">q</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <a class="idref" href="liblayers.simrel.MemOpv.html#K"><span class="id" title="variable">K</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">((</span></a><span class="id" title="var">_</span><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">,</span></a> <span class="id" title="var">_</span><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">),</span></a> <span class="id" title="var">_</span><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">((</span></a><span class="id" title="var">_</span><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">,</span></a> <span class="id" title="var">_</span><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">),</span></a> <span class="id" title="var">_</span><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">)</span></a>); <span class="id" title="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">constructor</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">split</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">revert</span> <span class="id" title="var">PERM1</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">eapply</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">q</span> <span class="id" title="var">K</span> ⇒ <a class="idref" href="liblayers.simrel.MemOpv.html#simrel_range_perm"><span class="id" title="instance">simrel_range_perm</span></a> <a class="idref" href="liblayers.simrel.MemOpv.html#q"><span class="id" title="variable">q</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <a class="idref" href="liblayers.simrel.MemOpv.html#K"><span class="id" title="variable">K</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">((</span></a><span class="id" title="var">_</span><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">,</span></a> <span class="id" title="var">_</span><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">),</span></a> <span class="id" title="var">_</span><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">((</span></a><span class="id" title="var">_</span><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">,</span></a> <span class="id" title="var">_</span><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">),</span></a> <span class="id" title="var">_</span><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">)</span></a>); <span class="id" title="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">constructor</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> (<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.ZArith.ZArith_dec.html#Z_eq_dec"><span class="id" title="abbreviation">Z_eq_dec</span></a> <span class="id" title="var">a</span> 0); <span class="id" title="tactic">try</span> <span class="id" title="tactic">intuition</span> <span class="id" title="tactic">omega</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">inversion</span> <span class="id" title="var">H0</span>; <span class="id" title="tactic">subst</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">inversion</span> <span class="id" title="var">H1</span>; <span class="id" title="tactic">subst</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">eapply</span> (<a class="idref" href="liblayers.simrel.SimrelDefinition.html#simrel_disjoint_or_equal_inject"><span class="id" title="method">simrel_disjoint_or_equal_inject</span></a> <span class="id" title="var">p</span>); <span class="id" title="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" title="tactic">eapply</span> <a class="idref" href="compcert.common.Memtype.html#Mem.range_perm_max"><span class="id" title="method">Mem.range_perm_max</span></a>; <span class="id" title="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" title="tactic">eapply</span> <a class="idref" href="compcert.common.Memtype.html#Mem.range_perm_max"><span class="id" title="method">Mem.range_perm_max</span></a>; <span class="id" title="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" title="tactic">omega</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Qed</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Global Instance</span> <a name="simrel_disjoint_or_equalv"><span class="id" title="instance">simrel_disjoint_or_equalv</span></a> <span class="id" title="var">p</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="coqrel.RelDefinitions.html#Monotonic"><span class="id" title="abbreviation">Monotonic</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="liblayers.simrel.MemOpv.html#disjoint_or_equalv"><span class="id" title="definition">Mem.disjoint_or_equalv</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="coqrel.Relators.html#da8817e538e6bc1d3d2ad0cfb530ab9c"><span class="id" title="notation">-</span></a> <a class="idref" href="coqrel.Relators.html#da8817e538e6bc1d3d2ad0cfb530ab9c"><span class="id" title="notation">==&gt;</span></a> <a class="idref" href="liblayers.simrel.SimrelDefinition.html#match_mem"><span class="id" title="projection">match_mem</span></a> <a class="idref" href="liblayers.simrel.MemOpv.html#SIMREL.R"><span class="id" title="variable">R</span></a> <a class="idref" href="liblayers.simrel.MemOpv.html#p"><span class="id" title="variable">p</span></a> <a class="idref" href="coqrel.RelDefinitions.html#d5d0ad6beccd25d5224442d64ed307d5"><span class="id" title="notation">++&gt;</span></a> <a class="idref" href="liblayers.simrel.SimrelDefinition.html#match_val"><span class="id" title="inductive">match_val</span></a> <a class="idref" href="liblayers.simrel.MemOpv.html#SIMREL.R"><span class="id" title="variable">R</span></a> <a class="idref" href="liblayers.simrel.MemOpv.html#p"><span class="id" title="variable">p</span></a> <a class="idref" href="coqrel.RelDefinitions.html#d5d0ad6beccd25d5224442d64ed307d5"><span class="id" title="notation">++&gt;</span></a> <a class="idref" href="liblayers.simrel.SimrelDefinition.html#match_val"><span class="id" title="inductive">match_val</span></a> <a class="idref" href="liblayers.simrel.MemOpv.html#SIMREL.R"><span class="id" title="variable">R</span></a> <a class="idref" href="liblayers.simrel.MemOpv.html#p"><span class="id" title="variable">p</span></a> <a class="idref" href="coqrel.RelDefinitions.html#d5d0ad6beccd25d5224442d64ed307d5"><span class="id" title="notation">++&gt;</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Program.Basics.html#impl"><span class="id" title="definition">impl</span></a>).<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <a class="idref" href="liblayers.simrel.MemOpv.html#disjoint_or_equalv"><span class="id" title="definition">Mem.disjoint_or_equalv</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">repeat</span> <span class="id" title="tactic">red</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">a</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> <span class="id" title="var">H</span> <span class="id" title="var">x0</span> <span class="id" title="var">y0</span> <span class="id" title="var">H0</span> <span class="id" title="var">x1</span> <span class="id" title="var">y1</span> <span class="id" title="var">H1</span> <span class="id" title="var">H2</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">inversion</span> <span class="id" title="var">H0</span>; <span class="id" title="tactic">subst</span>; <span class="id" title="tactic">try</span> <span class="id" title="var">contradiction</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">inversion</span> <span class="id" title="var">H1</span>; <span class="id" title="tactic">subst</span>; <span class="id" title="tactic">try</span> <span class="id" title="var">contradiction</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">generalize</span> <span class="id" title="var">H2</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">H2</span> <span class="id" title="keyword">as</span> (<span class="id" title="var">NONNEG</span> &amp; <span class="id" title="var">PERM0</span> &amp; <span class="id" title="var">PERM1</span> &amp; <span class="id" title="var">DISJ_OR_EQ</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> (<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.ZArith.BinInt.html#Z.eq_dec"><span class="id" title="definition">Z.eq_dec</span></a> <span class="id" title="var">a</span> 0).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">subst</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">_</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">red</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">split</span>; <span class="id" title="tactic">auto</span> <span class="id" title="keyword">with</span> <span class="id" title="var">zarith</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">split</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id" title="tactic">red</span>. <span class="id" title="tactic">intros</span>; <span class="id" title="tactic">omega</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">split</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id" title="tactic">red</span>. <span class="id" title="tactic">intros</span>; <span class="id" title="tactic">omega</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">right</span>; <span class="id" title="tactic">omega</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">assert</span> (<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Classes.Morphisms.html#Params"><span class="id" title="class">Params</span></a> (@<a class="idref" href="liblayers.simrel.MemOpv.html#disjoint_or_equal"><span class="id" title="definition">Mem.disjoint_or_equal</span></a>) 6) <span class="id" title="tactic">by</span> <span class="id" title="tactic">constructor</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">repeat</span> <span class="id" title="var">rstep</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">eapply</span> <a class="idref" href="liblayers.simrel.SimrelDefinition.html#match_ptrbits_ptr"><span class="id" title="lemma">match_ptrbits_ptr</span></a>; <span class="id" title="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">eapply</span> <span class="id" title="var">PERM0</span>. <span class="id" title="tactic">omega</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">eapply</span> <a class="idref" href="liblayers.simrel.SimrelDefinition.html#match_ptrbits_ptr"><span class="id" title="lemma">match_ptrbits_ptr</span></a>; <span class="id" title="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">eapply</span> <span class="id" title="var">PERM1</span>. <span class="id" title="tactic">omega</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Qed</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Global Instance</span> <a name="simrel_aligned_area"><span class="id" title="instance">simrel_aligned_area</span></a> <span class="id" title="var">p</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="coqrel.RelDefinitions.html#Monotonic"><span class="id" title="abbreviation">Monotonic</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="liblayers.simrel.MemOpv.html#aligned_area"><span class="id" title="definition">Mem.aligned_area</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="coqrel.Relators.html#da8817e538e6bc1d3d2ad0cfb530ab9c"><span class="id" title="notation">-</span></a> <a class="idref" href="coqrel.Relators.html#da8817e538e6bc1d3d2ad0cfb530ab9c"><span class="id" title="notation">==&gt;</span></a> <a class="idref" href="coqrel.Relators.html#da8817e538e6bc1d3d2ad0cfb530ab9c"><span class="id" title="notation">-</span></a> <a class="idref" href="coqrel.Relators.html#da8817e538e6bc1d3d2ad0cfb530ab9c"><span class="id" title="notation">==&gt;</span></a> <a class="idref" href="liblayers.simrel.SimrelDefinition.html#match_mem"><span class="id" title="projection">match_mem</span></a> <a class="idref" href="liblayers.simrel.MemOpv.html#SIMREL.R"><span class="id" title="variable">R</span></a> <a class="idref" href="liblayers.simrel.MemOpv.html#p"><span class="id" title="variable">p</span></a> <a class="idref" href="coqrel.RelDefinitions.html#d5d0ad6beccd25d5224442d64ed307d5"><span class="id" title="notation">++&gt;</span></a> <a class="idref" href="coqrel.RelOperators.html#rel_curry"><span class="id" title="definition">rel_curry</span></a> (<a class="idref" href="liblayers.simrel.SimrelDefinition.html#match_ptr"><span class="id" title="inductive">match_ptr</span></a> <a class="idref" href="liblayers.simrel.MemOpv.html#SIMREL.R"><span class="id" title="variable">R</span></a> <a class="idref" href="liblayers.simrel.MemOpv.html#p"><span class="id" title="variable">p</span></a> <a class="idref" href="coqrel.RelDefinitions.html#d5d0ad6beccd25d5224442d64ed307d5"><span class="id" title="notation">++&gt;</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Program.Basics.html#impl"><span class="id" title="definition">impl</span></a>)).<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">repeat</span> <span class="id" title="tactic">red</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">a</span> <span class="id" title="var">a0</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> <span class="id" title="var">H</span> [<span class="id" title="var">b</span> <span class="id" title="var">o</span>] [<span class="id" title="var">b'</span> <span class="id" title="var">o'</span>] <span class="id" title="var">H0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <a class="idref" href="liblayers.simrel.MemOpv.html#aligned_area"><span class="id" title="definition">Mem.aligned_area</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> 1 <span class="id" title="keyword">as</span> (<span class="id" title="var">AL_EQ</span> &amp; <span class="id" title="var">ALIGN_SZ</span> &amp; <span class="id" title="var">PERM</span> &amp; <span class="id" title="var">ALIGN</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">split</span>; <span class="id" title="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">split</span>; <span class="id" title="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">split</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">revert</span> <span class="id" title="var">PERM</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">eapply</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">q</span> <span class="id" title="var">K</span> ⇒ <a class="idref" href="liblayers.simrel.MemOpv.html#simrel_range_perm"><span class="id" title="instance">simrel_range_perm</span></a> <a class="idref" href="liblayers.simrel.MemOpv.html#q"><span class="id" title="variable">q</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <a class="idref" href="liblayers.simrel.MemOpv.html#K"><span class="id" title="variable">K</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">((</span></a><span class="id" title="var">_</span><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">,</span></a> <span class="id" title="var">_</span><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">),</span></a> <span class="id" title="var">_</span><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">((</span></a><span class="id" title="var">_</span><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">,</span></a> <span class="id" title="var">_</span><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">),</span></a> <span class="id" title="var">_</span><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">)</span></a>); <span class="id" title="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">constructor</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">inversion</span> <span class="id" title="var">H0</span>; <span class="id" title="tactic">subst</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">H1</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">eapply</span> (<a class="idref" href="liblayers.simrel.SimrelDefinition.html#simrel_aligned_area_inject"><span class="id" title="method">simrel_aligned_area_inject</span></a> <span class="id" title="var">p</span>); <span class="id" title="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Qed</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Global Instance</span> <a name="simrel_aligned_areav"><span class="id" title="instance">simrel_aligned_areav</span></a> <span class="id" title="var">p</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="coqrel.RelDefinitions.html#Monotonic"><span class="id" title="abbreviation">Monotonic</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="liblayers.simrel.MemOpv.html#aligned_areav"><span class="id" title="definition">Mem.aligned_areav</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="coqrel.Relators.html#da8817e538e6bc1d3d2ad0cfb530ab9c"><span class="id" title="notation">-</span></a> <a class="idref" href="coqrel.Relators.html#da8817e538e6bc1d3d2ad0cfb530ab9c"><span class="id" title="notation">==&gt;</span></a> <a class="idref" href="coqrel.Relators.html#da8817e538e6bc1d3d2ad0cfb530ab9c"><span class="id" title="notation">-</span></a> <a class="idref" href="coqrel.Relators.html#da8817e538e6bc1d3d2ad0cfb530ab9c"><span class="id" title="notation">==&gt;</span></a> <a class="idref" href="liblayers.simrel.SimrelDefinition.html#match_mem"><span class="id" title="projection">match_mem</span></a> <a class="idref" href="liblayers.simrel.MemOpv.html#SIMREL.R"><span class="id" title="variable">R</span></a> <a class="idref" href="liblayers.simrel.MemOpv.html#p"><span class="id" title="variable">p</span></a> <a class="idref" href="coqrel.RelDefinitions.html#d5d0ad6beccd25d5224442d64ed307d5"><span class="id" title="notation">++&gt;</span></a> <a class="idref" href="liblayers.simrel.SimrelDefinition.html#match_val"><span class="id" title="inductive">match_val</span></a> <a class="idref" href="liblayers.simrel.MemOpv.html#SIMREL.R"><span class="id" title="variable">R</span></a> <a class="idref" href="liblayers.simrel.MemOpv.html#p"><span class="id" title="variable">p</span></a> <a class="idref" href="coqrel.RelDefinitions.html#d5d0ad6beccd25d5224442d64ed307d5"><span class="id" title="notation">++&gt;</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Program.Basics.html#impl"><span class="id" title="definition">impl</span></a>).<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">repeat</span> <span class="id" title="tactic">red</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <a class="idref" href="liblayers.simrel.MemOpv.html#aligned_areav"><span class="id" title="definition">Mem.aligned_areav</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">a</span> <span class="id" title="var">a0</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> <span class="id" title="var">H</span> <span class="id" title="var">x0</span> <span class="id" title="var">y0</span> <span class="id" title="var">H0</span> <span class="id" title="var">H1</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">inversion</span> <span class="id" title="var">H0</span>; <span class="id" title="tactic">subst</span>; <span class="id" title="tactic">try</span> <span class="id" title="var">contradiction</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> (<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.ZArith.ZArith_dec.html#Z_gt_dec"><span class="id" title="definition">Z_gt_dec</span></a> <span class="id" title="var">a0</span> 0).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">generalize</span> <span class="id" title="var">H1</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">assert</span> (<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Classes.Morphisms.html#Params"><span class="id" title="class">Params</span></a> (@<a class="idref" href="liblayers.simrel.MemOpv.html#aligned_area"><span class="id" title="definition">Mem.aligned_area</span></a>) 5) <span class="id" title="tactic">by</span> <span class="id" title="tactic">constructor</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">repeat</span> <span class="id" title="var">rstep</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">eapply</span> <a class="idref" href="liblayers.simrel.SimrelDefinition.html#match_ptrbits_ptr"><span class="id" title="lemma">match_ptrbits_ptr</span></a>; <span class="id" title="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">eapply</span> <span class="id" title="var">H1</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">omega</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <a class="idref" href="liblayers.simrel.MemOpv.html#aligned_area"><span class="id" title="definition">Mem.aligned_area</span></a> <span class="id" title="keyword">in</span> ×.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <a class="idref" href="compcert.common.Memtype.html#Mem.range_perm"><span class="id" title="method">Mem.range_perm</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intuition</span> <span class="id" title="tactic">omega</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Qed</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Global Instance</span> <a name="simrel_freev"><span class="id" title="instance">simrel_freev</span></a> <span class="id" title="var">p</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="coqrel.RelDefinitions.html#Monotonic"><span class="id" title="abbreviation">Monotonic</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="liblayers.simrel.MemOpv.html#freev"><span class="id" title="definition">Mem.freev</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="liblayers.simrel.SimrelDefinition.html#match_mem"><span class="id" title="projection">match_mem</span></a> <a class="idref" href="liblayers.simrel.MemOpv.html#SIMREL.R"><span class="id" title="variable">R</span></a> <a class="idref" href="liblayers.simrel.MemOpv.html#p"><span class="id" title="variable">p</span></a> <a class="idref" href="coqrel.RelDefinitions.html#d5d0ad6beccd25d5224442d64ed307d5"><span class="id" title="notation">++&gt;</span></a> <a class="idref" href="liblayers.simrel.SimrelDefinition.html#match_val"><span class="id" title="inductive">match_val</span></a> <a class="idref" href="liblayers.simrel.MemOpv.html#SIMREL.R"><span class="id" title="variable">R</span></a> <a class="idref" href="liblayers.simrel.MemOpv.html#p"><span class="id" title="variable">p</span></a> <a class="idref" href="coqrel.RelDefinitions.html#d5d0ad6beccd25d5224442d64ed307d5"><span class="id" title="notation">++&gt;</span></a> <a class="idref" href="coqrel.Relators.html#da8817e538e6bc1d3d2ad0cfb530ab9c"><span class="id" title="notation">-</span></a> <a class="idref" href="coqrel.Relators.html#da8817e538e6bc1d3d2ad0cfb530ab9c"><span class="id" title="notation">==&gt;</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="liblayers.logic.OptionOrders.html#option_le"><span class="id" title="inductive">option_le</span></a> (<a class="idref" href="liblayers.simrel.SimrelDefinition.html#238e5b84009b7e00668800f6e2df3b39"><span class="id" title="notation">incr</span></a> <a class="idref" href="liblayers.simrel.MemOpv.html#p"><span class="id" title="variable">p</span></a> <a class="idref" href="liblayers.simrel.SimrelDefinition.html#238e5b84009b7e00668800f6e2df3b39"><span class="id" title="notation">(</span></a><a class="idref" href="liblayers.simrel.SimrelDefinition.html#match_mem"><span class="id" title="projection">match_mem</span></a> <a class="idref" href="liblayers.simrel.MemOpv.html#SIMREL.R"><span class="id" title="variable">R</span></a> <a class="idref" href="liblayers.simrel.MemOpv.html#p"><span class="id" title="variable">p</span></a><a class="idref" href="liblayers.simrel.SimrelDefinition.html#238e5b84009b7e00668800f6e2df3b39"><span class="id" title="notation">)</span></a>)).<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> <span class="id" title="var">H</span> <span class="id" title="var">x0</span> <span class="id" title="var">y0</span> <span class="id" title="var">H0</span> <span class="id" title="var">a</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">inversion</span> <span class="id" title="var">H0</span>; <span class="id" title="tactic">subst</span>; <span class="id" title="tactic">try</span> <span class="id" title="var">now</span> <span class="id" title="var">solve_monotonic</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> (<a class="idref" href="compcert.common.Memtype.html#Mem.free"><span class="id" title="method">Mem.free</span></a> <span class="id" title="var">x</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>) <span class="id" title="var">eqn</span>:<span class="id" title="var">FREE</span>; <span class="id" title="tactic">try</span> <span class="id" title="var">now</span> <span class="id" title="var">solve_monotonic</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> (<a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.ZArith.ZArith_dec.html#Z_le_dec"><span class="id" title="definition">Z_le_dec</span></a> <span class="id" title="var">a</span> 0).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">exploit</span> (<a class="idref" href="compcertx.common.MemoryX.html#Mem.free_range"><span class="id" title="method">Mem.free_range</span></a> <span class="id" title="var">x</span>); <span class="id" title="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> 1; <span class="id" title="tactic">subst</span>; <span class="id" title="tactic">try</span> <span class="id" title="tactic">omega</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> (<a class="idref" href="compcert.common.Memtype.html#Mem.range_perm_free"><span class="id" title="lemma">Mem.range_perm_free</span></a> <span class="id" title="var">y</span> <span class="id" title="var">b2</span> (<a class="idref" href="compcert.lib.Integers.html#Ptrofs.unsigned"><span class="id" title="definition">Ptrofs.unsigned</span></a> <span class="id" title="var">ofs2</span>) (<a class="idref" href="compcert.lib.Integers.html#Ptrofs.unsigned"><span class="id" title="definition">Ptrofs.unsigned</span></a> <span class="id" title="var">ofs2</span> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.ZArith.BinInt.html#a3448b794f7a26d611ad36492b5d640b"><span class="id" title="notation">+</span></a> <span class="id" title="var">a</span>)) <span class="id" title="keyword">as</span> [? <span class="id" title="var">FREE2</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">red</span>. <span class="id" title="tactic">intros</span> <span class="id" title="var">ofs</span> <span class="id" title="var">H2</span>. <span class="id" title="tactic">omega</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">exploit</span> (<a class="idref" href="compcertx.common.MemoryX.html#Mem.free_range"><span class="id" title="method">Mem.free_range</span></a> <span class="id" title="var">y</span>); <span class="id" title="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> 1; <span class="id" title="tactic">subst</span>; <span class="id" title="tactic">try</span> <span class="id" title="tactic">omega</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">FREE2</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">solve_monotonic</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> &lt;- <span class="id" title="var">FREE</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">K</span> ⇒ <a class="idref" href="liblayers.simrel.SimrelDefinition.html#simrel_free"><span class="id" title="method">simrel_free</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <a class="idref" href="liblayers.simrel.MemOpv.html#K"><span class="id" title="variable">K</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">((</span></a><span class="id" title="var">_</span><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">,</span></a> <span class="id" title="var">_</span><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">),</span></a> <span class="id" title="var">_</span><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">((</span></a><span class="id" title="var">_</span><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">,</span></a> <span class="id" title="var">_</span><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">),</span></a> <span class="id" title="var">_</span><a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">)</span></a>); <span class="id" title="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">constructor</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">eapply</span> <a class="idref" href="liblayers.simrel.SimrelDefinition.html#match_ptrbits_ptr"><span class="id" title="lemma">match_ptrbits_ptr</span></a>; <span class="id" title="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">eapply</span> <a class="idref" href="compcert.common.Memtype.html#Mem.free_range_perm"><span class="id" title="method">Mem.free_range_perm</span></a>; <span class="id" title="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">omega</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Qed</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Global Instance</span> <a name="mem_valid_pointerv_match"><span class="id" title="instance">mem_valid_pointerv_match</span></a> <span class="id" title="var">p</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="coqrel.RelDefinitions.html#Monotonic"><span class="id" title="abbreviation">Monotonic</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="liblayers.simrel.MemOpv.html#valid_pointerv"><span class="id" title="definition">Mem.valid_pointerv</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="liblayers.simrel.SimrelDefinition.html#match_mem"><span class="id" title="projection">match_mem</span></a> <a class="idref" href="liblayers.simrel.MemOpv.html#SIMREL.R"><span class="id" title="variable">R</span></a> <a class="idref" href="liblayers.simrel.MemOpv.html#p"><span class="id" title="variable">p</span></a> <a class="idref" href="coqrel.RelDefinitions.html#d5d0ad6beccd25d5224442d64ed307d5"><span class="id" title="notation">++&gt;</span></a> <a class="idref" href="liblayers.simrel.SimrelDefinition.html#match_val"><span class="id" title="inductive">match_val</span></a> <a class="idref" href="liblayers.simrel.MemOpv.html#SIMREL.R"><span class="id" title="variable">R</span></a> <a class="idref" href="liblayers.simrel.MemOpv.html#p"><span class="id" title="variable">p</span></a> <a class="idref" href="coqrel.RelDefinitions.html#d5d0ad6beccd25d5224442d64ed307d5"><span class="id" title="notation">++&gt;</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Bool.Bool.html#leb"><span class="id" title="definition">Bool.leb</span></a>).<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <a class="idref" href="liblayers.simrel.MemOpv.html#valid_pointerv"><span class="id" title="definition">Mem.valid_pointerv</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">m1</span> <span class="id" title="var">m2</span> <span class="id" title="var">Hm</span> <span class="id" title="var">v1</span> <span class="id" title="var">v2</span> <span class="id" title="var">Hv</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">inversion</span> <span class="id" title="var">Hv</span>; <span class="id" title="tactic">subst</span>; <span class="id" title="tactic">try</span> <span class="id" title="var">now</span> <span class="id" title="tactic">constructor</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> (<a class="idref" href="compcert.common.Memtype.html#Mem.valid_pointer"><span class="id" title="method">Mem.valid_pointer</span></a> <span class="id" title="var">m1</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>) <span class="id" title="var">eqn</span>:<span class="id" title="var">VALID</span>; <span class="id" title="tactic">try</span> <span class="id" title="var">now</span> <span class="id" title="tactic">constructor</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> &lt;- <span class="id" title="var">VALID</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">repeat</span> <span class="id" title="var">rstep</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">eapply</span> <a class="idref" href="liblayers.simrel.SimrelDefinition.html#match_ptrbits_ptr"><span class="id" title="lemma">match_ptrbits_ptr</span></a>; <span class="id" title="tactic">eauto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">eapply</span> <a class="idref" href="compcert.common.Memtype.html#Mem.valid_pointer_nonempty_perm"><span class="id" title="method">Mem.valid_pointer_nonempty_perm</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
The following is NOT a consequence of other
      <span class="inlinecode"><a class="idref" href="liblayers.simrel.SimrelDefinition.html#mem_valid_pointer_match"><span class="id" title="instance">mem_valid_pointer_match</span></a></span>, but rather follows from the
      <span class="inlinecode"><a class="idref" href="compcert.common.Memtype.html#Mem.weak_valid_pointer_inject_val"><span class="id" title="projection">weak_valid_pointer_inject_val</span></a></span> requirement. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Global Instance</span> <a name="mem_weak_valid_pointerv_match"><span class="id" title="instance">mem_weak_valid_pointerv_match</span></a> <span class="id" title="var">p</span>:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="coqrel.RelDefinitions.html#Monotonic"><span class="id" title="abbreviation">Monotonic</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="liblayers.simrel.MemOpv.html#weak_valid_pointerv"><span class="id" title="definition">Mem.weak_valid_pointerv</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="liblayers.simrel.SimrelDefinition.html#match_mem"><span class="id" title="projection">match_mem</span></a> <a class="idref" href="liblayers.simrel.MemOpv.html#SIMREL.R"><span class="id" title="variable">R</span></a> <a class="idref" href="liblayers.simrel.MemOpv.html#p"><span class="id" title="variable">p</span></a> <a class="idref" href="coqrel.RelDefinitions.html#d5d0ad6beccd25d5224442d64ed307d5"><span class="id" title="notation">++&gt;</span></a> <a class="idref" href="liblayers.simrel.SimrelDefinition.html#match_val"><span class="id" title="inductive">match_val</span></a> <a class="idref" href="liblayers.simrel.MemOpv.html#SIMREL.R"><span class="id" title="variable">R</span></a> <a class="idref" href="liblayers.simrel.MemOpv.html#p"><span class="id" title="variable">p</span></a> <a class="idref" href="coqrel.RelDefinitions.html#d5d0ad6beccd25d5224442d64ed307d5"><span class="id" title="notation">++&gt;</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Bool.Bool.html#leb"><span class="id" title="definition">Bool.leb</span></a>).<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">m1</span> <span class="id" title="var">m2</span> <span class="id" title="var">Hm</span> <span class="id" title="var">v1</span> <span class="id" title="var">v2</span> <span class="id" title="var">Hv</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> (<a class="idref" href="liblayers.simrel.MemOpv.html#weak_valid_pointerv"><span class="id" title="definition">Mem.weak_valid_pointerv</span></a> <span class="id" title="var">m1</span> <span class="id" title="var">_</span>) <span class="id" title="var">eqn</span>:<span class="id" title="var">VALID</span>; <span class="id" title="tactic">try</span> <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">inversion</span> <span class="id" title="var">Hv</span>; <span class="id" title="tactic">subst</span>; <span class="id" title="tactic">try</span> <span class="id" title="tactic">discriminate</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">eapply</span> (<a class="idref" href="liblayers.simrel.SimrelDefinition.html#simrel_weak_valid_pointer_inject_val"><span class="id" title="method">simrel_weak_valid_pointer_inject_val</span></a> <span class="id" title="var">p</span>); <span class="id" title="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Qed</span>.<br/>
<span class="id" title="keyword">End</span> <a class="idref" href="liblayers.simrel.MemOpv.html#SIMREL"><span class="id" title="section">SIMREL</span></a>.<br/>

<br/>
<span class="id" title="keyword">Global Instance</span>: <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Classes.Morphisms.html#Params"><span class="id" title="class">Params</span></a> (@<a class="idref" href="liblayers.simrel.MemOpv.html#loadbytesv"><span class="id" title="definition">Mem.loadbytesv</span></a>) 3.<br/>
<span class="id" title="keyword">Global Instance</span>: <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Classes.Morphisms.html#Params"><span class="id" title="class">Params</span></a> (@<a class="idref" href="liblayers.simrel.MemOpv.html#storebytesv"><span class="id" title="definition">Mem.storebytesv</span></a>) 3.<br/>
<span class="id" title="keyword">Global Instance</span>: <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Classes.Morphisms.html#Params"><span class="id" title="class">Params</span></a> (@<a class="idref" href="liblayers.simrel.MemOpv.html#permv"><span class="id" title="definition">Mem.permv</span></a>) 3.<br/>
<span class="id" title="keyword">Global Instance</span>: <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Classes.Morphisms.html#Params"><span class="id" title="class">Params</span></a> (@<a class="idref" href="liblayers.simrel.MemOpv.html#disjoint_or_equal"><span class="id" title="definition">Mem.disjoint_or_equal</span></a>) 6.<br/>
<span class="id" title="keyword">Global Instance</span>: <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Classes.Morphisms.html#Params"><span class="id" title="class">Params</span></a> (@<a class="idref" href="liblayers.simrel.MemOpv.html#disjoint_or_equalv"><span class="id" title="definition">Mem.disjoint_or_equalv</span></a>) 4.<br/>
<span class="id" title="keyword">Global Instance</span>: <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Classes.Morphisms.html#Params"><span class="id" title="class">Params</span></a> (@<a class="idref" href="liblayers.simrel.MemOpv.html#aligned_area"><span class="id" title="definition">Mem.aligned_area</span></a>) 5.<br/>
<span class="id" title="keyword">Global Instance</span>: <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Classes.Morphisms.html#Params"><span class="id" title="class">Params</span></a> (@<a class="idref" href="liblayers.simrel.MemOpv.html#aligned_areav"><span class="id" title="definition">Mem.aligned_areav</span></a>) 4.<br/>
<span class="id" title="keyword">Global Instance</span>: <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Classes.Morphisms.html#Params"><span class="id" title="class">Params</span></a> (@<a class="idref" href="liblayers.simrel.MemOpv.html#freev"><span class="id" title="definition">Mem.freev</span></a>) 3.<br/>
<span class="id" title="keyword">Global Instance</span>: <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Classes.Morphisms.html#Params"><span class="id" title="class">Params</span></a> (@<a class="idref" href="liblayers.simrel.MemOpv.html#valid_pointerv"><span class="id" title="definition">Mem.valid_pointerv</span></a>) 2.<br/>
<span class="id" title="keyword">Global Instance</span>: <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Classes.Morphisms.html#Params"><span class="id" title="class">Params</span></a> (@<a class="idref" href="liblayers.simrel.MemOpv.html#weak_valid_pointerv"><span class="id" title="definition">Mem.weak_valid_pointerv</span></a>) 2.<br/>
<span class="id" title="keyword">Global Instance</span>: <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Classes.Morphisms.html#Params"><span class="id" title="class">Params</span></a> (@<a class="idref" href="compcert.common.Memtype.html#Mem.range_perm"><span class="id" title="method">Mem.range_perm</span></a>) 6.<br/>
<span class="id" title="keyword">Global Instance</span>: <a class="idref" href="http://coq.inria.fr/distrib/8.6/stdlib/Coq.Classes.Morphisms.html#Params"><span class="id" title="class">Params</span></a> (@<a class="idref" href="liblayers.simrel.MemOpv.html#range_permv"><span class="id" title="definition">Mem.range_permv</span></a>) 4.<br/>
</div>
</div>

<div id="footer">
<hr/><a href="index.html">Index</a><hr/>This page has been generated by <a href="http://coq.inria.fr/">coqdoc</a>
</div>

</div>

</body>
</html>